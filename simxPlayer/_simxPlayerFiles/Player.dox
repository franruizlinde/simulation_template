/**
 * Dummy namespace to enable search in doxygen output
 */
namespace _ {
// start of C:\206-3_11\devAppPlayer\src\appPlayer.cpp
// END of C:\206-3_11\devAppPlayer\src\appPlayer.cpp
//-------------------------------------------------
// start of C:\206-3_11\devAppPlayer\src\libinitializer.c
// END of C:\206-3_11\devAppPlayer\src\libinitializer.c
//-------------------------------------------------
// start of C:\206-3_11\libSAL\src\SAL_Error.c
/**
 * @file SAL_Error.c
 * @brief ToString function for SAL_Error_e enum
 * @note Autogenerated file
 */
//level=0 fn=C:\206-3_11\libSAL\src\SAL_Error.c li=5

// END of C:\206-3_11\libSAL\src\SAL_Error.c
//-------------------------------------------------
// start of C:\206-3_11\libSAL\src\SAL_Ftw.c
/**
 * @file SAL_Ftw.c
 * @brief libSAL Ftw file provides ftw/nftw abstraction Ubuntu iOS, or implementation for Windows
 * @date 31/05/2016
 * @author @balyo.com
 **/
//level=0 fn=C:\206-3_11\libSAL\src\SAL_Ftw.c li=1

// END of C:\206-3_11\libSAL\src\SAL_Ftw.c
//-------------------------------------------------
// start of C:\206-3_11\libSAL\src\SAL_Serial.c
/**
 * @file libSAL/SAL_Serial.c
 * @brief This file contains sources about serial abstraction layer
 * @date 12/06/2016
 * @author frederic.dhaeyer@balyo.com
 */
//level=0 fn=C:\206-3_11\libSAL\src\SAL_Serial.c li=1

// END of C:\206-3_11\libSAL\src\SAL_Serial.c
//-------------------------------------------------
// start of C:\206-3_11\libSAL\src\SAL_Socket.c
/**
 * @file libSAL/SAL_Socket.c
 * @brief This file contains sources about socket abstraction layer
 * @date 02/03/2016
 * @author frederic.dhaeyer@balyo.com
 */
//level=0 fn=C:\206-3_11\libSAL\src\SAL_Socket.c li=1

// END of C:\206-3_11\libSAL\src\SAL_Socket.c
//-------------------------------------------------
// start of C:\206-3_11\libSAL\src\SAL_String.c
/**
 * @file SAL_Types.c
 * @brief This file contains source about Software Abstraction Layer types.
 * @date 07/09/2015
 * @author frederic.dhaeyer@balyo.com
 **/
//level=0 fn=C:\206-3_11\libSAL\src\SAL_String.c li=1

// END of C:\206-3_11\libSAL\src\SAL_String.c
//-------------------------------------------------
// start of C:\206-3_11\libSAL\src\SAL_Time.c
/**
 * @file src/SAL_Time.c
 * @brief This file contains source about Software Abstraction Layer for time API.
 * @date 07/09/2015
 * @author frederic.dhaeyer@balyo.com
 **/
//level=0 fn=C:\206-3_11\libSAL\src\SAL_Time.c li=1

// END of C:\206-3_11\libSAL\src\SAL_Time.c
//-------------------------------------------------
// start of C:\206-3_11\libSAL\src\SAL_Types.c
/**
 * @file SAL_Types.c
 * @brief This file contains source about Software Abstraction Layer types.
 * @date 07/09/2015
 * @author frederic.dhaeyer@balyo.com
 **/
//level=0 fn=C:\206-3_11\libSAL\src\SAL_Types.c li=1

// END of C:\206-3_11\libSAL\src\SAL_Types.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_Error.c
/**
 * @file UTILS_Error.c
 * @brief ToString function for UTILS_Error_e enum
 * @note Autogenerated file
 */
//level=0 fn=C:\206-3_11\libUtils\src\UTILS_Error.c li=5

// END of C:\206-3_11\libUtils\src\UTILS_Error.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_FileSystem.c
/**
 * @file UTILS_FileSystem.c
 * @brief
 * @date 31/05/2016
 * @author @balyo.com
 **/
//level=0 fn=C:\206-3_11\libUtils\src\UTILS_FileSystem.c li=1

// END of C:\206-3_11\libUtils\src\UTILS_FileSystem.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_Geom.c
// END of C:\206-3_11\libUtils\src\UTILS_Geom.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_Graph.c
/**
 * @file UTILS_Graph.c
 * @brief file containing source file about utils graph
 * @author marc.vanderlinden@balyo.com
*/
//level=0 fn=C:\206-3_11\libUtils\src\UTILS_Graph.c li=1

// END of C:\206-3_11\libUtils\src\UTILS_Graph.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_LinkedList.c
/**
 * @file UTILS_LinkedList.c
 * @brief file containing source file about utils linked list
 * @author marc.vanderlinden@balyo.com
*/
//level=0 fn=C:\206-3_11\libUtils\src\UTILS_LinkedList.c li=1

// END of C:\206-3_11\libUtils\src\UTILS_LinkedList.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_List.c
/**
 * @file UTILS_List.c
 * @brief file containing source file about utils list
 * @author marc.vanderlinden@balyo.com
 */
//level=0 fn=C:\206-3_11\libUtils\src\UTILS_List.c li=1

// END of C:\206-3_11\libUtils\src\UTILS_List.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_Math.c
// END of C:\206-3_11\libUtils\src\UTILS_Math.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_Path.c
/**
 * @file libUtils/src/UTILS_Path.c
 * @brief File containing source about robot path.
 */
//level=0 fn=C:\206-3_11\libUtils\src\UTILS_Path.c li=1

// END of C:\206-3_11\libUtils\src\UTILS_Path.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_PeriodicThread.c
/**
 * @file libUtils/src/UTILS_PeriodicThread.c
 * @brief This file contains periodic thread source.
 * @date 06/08/2015
 * @author olivier.balland@balyo.com
 */
//level=0 fn=C:\206-3_11\libUtils\src\UTILS_PeriodicThread.c li=1

// END of C:\206-3_11\libUtils\src\UTILS_PeriodicThread.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_Polygon.c
// END of C:\206-3_11\libUtils\src\UTILS_Polygon.c
//-------------------------------------------------
// start of C:\206-3_11\libUtils\src\UTILS_String.c
// END of C:\206-3_11\libUtils\src\UTILS_String.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\scp_rlab\rls.cpp
/**
 *  @addtogroup rlab_file
 *  @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\rls.cpp li=1

/**
 * List recursively files in a given directory.
 * The full path is given in result list \a files.
 * @param path *L.char*
 * @param recursiveFlag *long*  optional and set by default to 1.
 * Use 0 to not scan recursive directory.
 * @return files (L2.char)
 */
files rls( void path,  void recursiveFlag) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\rls.cpp li=8

/**
 * List recursively files in a given directory.
 * The relative path to *rootPath* is given in result list *files*.
 * starting path is concatenation of \a rootPath and \a relPath
 * @param rootPath *L.char*
 * @param relPath *long*
 * @param filt *L.char*  selection filter
 * @return files (L2.char)
 * @return files *long*
 */
files files rells( void rootPath,  void relPath,  void filt) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\rls.cpp li=37

/**
 * Copy directories.
 * Be careful at path ending :
 *  * (if from = '.../toto') copy the *content* of toto
 *  * (if to = '.../tata')   to .../tata eventually created.
 *  * (if to = '.../tata/')  to .../tata/toto eventually created.
 * @param from
 * @param to
 */
copyDir( void from,  void to) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\rls.cpp li=89

/**
 * Create one ore more directory missing in the path.
 * * 'D:/toto/tata' -> creates 'toto'
 * * 'D:/toto/tata/' -> creates 'toto' and then 'tata'
 * @param path
 */
creatDir( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\rls.cpp li=119

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\scp_rlab\rls.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\scp_rlab\tests_utils.cpp
// END of C:\206-3_11\devLibRlab\scp_rlab\tests_utils.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp
/**
   @addtogroup rlab_unit_tests
   @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp li=1

/**
   Equality test.
   Test that a and b are same values. Print a pass/failed msg according to
   the test result.
   @param a
   @param b
   @param msg *string* to append to printed message
 */
utestEqual( void a,  void b,  void msg) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp li=14

/**
   Equality test.
   Test that `fnc(args)` and *res* are same values. Print a pass/failed msg
   according to the test result.
   @param fnc function to test
   @param args *fnc* arguments
   @param res expected result
 */
utestFncEqual( void fnc,  void args,  void res) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp li=42

/**
   Init unit test module.
   Must be called before any other unit_tests module function.
 */
utestStart() {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp li=56

/**
   Print tests results: total number of tests passed, etc
   @return 0 if success or number of tests that failed
 */
UNK utestEnd() {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp li=72

/**
   Declare function that setup a working environment for the testing code.
   Fixture is runned before running each test.
   To call between utestStart() and the first call to utest()
   @param feat
   @param fixtures
 */
utestStartFeat( void feat,  void fixtures) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp li=90

/**
   Print tests results: total number of tests passed, etc for current feature
   @return 0 if success or number of tests that failed
 */
UNK utestEndFeat() {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp li=109

/**
   Execute test
   @param fun
 */
utest( void fun) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp li=132

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\scp_rlab\unitTests.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\scp_rlab\utils.cpp
/**
   @addtogroup Utils
   @{
   Various utility functions
 */
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=1

/**
   Return a list of pairs, where the i-th pair contains the i-th element
   from each of the argument lists.
   The returned list is truncated in length to the length of the shortest
   argument sequence.
 */
zip() {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=8

/**
   Return a string which is the concatenation of the \a lst stringlist using \a sep
   as separator.
   @param lst \a [L.L.char|strn] stringlist
   @param sep \a string separator. default:' '
   @return \a *string* a new string
 */
UNK strJoin( void lst,  void sep) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=24

/**
   Return a list of the words in the string, using \a sep as the delimiter string.
   @param str *string* to split
   @param seps {L.name) string separators
   @return s *string*  splitted string
 */
s strSplit( void str,  void seps) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=48

/**
  Convert a list of numbers or strn to a list of strings.
  @param lst *L.void*  elements to convert
  @param nb0 *Long*  (optional) Number of digit to display. Only for double of cpx.
  @return stringlist *L.string*
 */
stringlist lstCharify( void lst,  void nb0) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=77

/**
   Get hexa representation of a color triplet.
   @code
   getHexaColor([0,255,128]) =>  '#00ff80'
   @endcode

   @param color \a [long] color triplet
 */
getHexaColor( void color) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=108

/**
   Partial merge of varspc b into a by considering only the fields of b that
   exist in a
   @param[in,out] a \a varspc to merge into
   @param b \a varspc
 */
setExistingVar( void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=121

/**
  Add fields only defined in varspc b into of varspc a. If field already exists, it will not be changed
  @param[in,out] a \a varspc to merge into
  @param b \a varspc
 */
setUnexistingVar( void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=135

/**
  Rename a field of a varspc.
  @param v *varspc*
  @param fieldOri *L.char* field to remove
  @param newField *L.char* new field to add
  @return v *varspc* modified
 */
v varspcRenameField( void v,  void fieldOri,  void newField) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=150

/**
  Execute a find command on field of a list of varspc
  @param allData *L.varspc* list of varspc
  @param ids *L.long* list of ids to find
  @param idName *L.char* name field to match with `ids`
  @return idxs *L.long* list of indexes, same size than `idx`
  Example :
  @verbatim
  lvarspcFind(varspc('id',[4,1,2]) ,[4,2,3],'id') = [0,2,-1]
  @endverbatim
 */
idxs lvarspcFind( void allData,  void ids,  void idName) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=170

/**
    strReadDouble() that returns default value when conversion fails.
   @param str \a string to convert to double
   @param val \a string to return if conversion failed
   @return string
 */
string readDoubleNofail( void str,  void val) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=194

/**
   strReadLong() that returns default value if conversion fails
   @param str \a string to convert to long
   @param val \a string to return if conversion failed
   @return string
 */
string readLongNofail( void str,  void val) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=205

/**
   Optional function call that prints a warning into console when function
   not present.
 */
optcall() {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=216

/**
   Call *fn* if time elapsed since *prevTime* is greater than *delay*.
 */
tempoCall() {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=236

/**
   Flatten out nested lists
   @param l L2.*
   @return L.*
 */
UNK flatten( void l) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=249

/**
   Give the binary conversion of a number
   @param num *long*
   @return res *L.long* ( MSB = res.(end) )
 */
res long2bit( void num) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=266

/**
   Give the binary conversion of a number
   @param tab *L.long* ( MSB = tab.(end) )
   @return res *long*
 */
res bit2long( void tab) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=288

/**
    Return a string in title case (first letter upper cased)
    @param str *L.char*
	@param enforceLowerCase *Long* enforce lower case on all letters but first
    @return res *L.char* input string converted in title case
*/
res totitle( void str,  void enforceLowerCase) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=302

/**
  Transforms a list of strn into a cell
  @param lname *strn*
  @return res *Cell*
 */
res strn2Cell( void lname) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=321

/**
  Transforms a cell of char into a list of strn
  @param lname *Cell.L.char*
  @return res *strn*
 */
res cell2Strn( void lname) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=332

/**
    Build a varspc by appending n occurences of each v fields
    @param v *varspc* to multiply
    @param n *long* output fields size
    @return res *varspc*
*/
res multVarspc( void v,  void n) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=343

/**
    Returns true if \a str starts with \a beg
    @param *L.char*
    @param *L.char*
*/
startsWith( void UNK,  void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=365

/**
    Decompose a duration into (days,hours,minutes,seconds,tuples)
*/
timetuple() {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=375

/**
    Verifie la presence d'un HWModule

    @param module   *char* nom du module recherche
    @return present *long* flag indiquant s'il est present
*/
present isModule( void module) {}
//level=1 fn=C:\206-3_11\devLibRlab\scp_rlab\utils.cpp li=386

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\scp_rlab\utils.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\rlab.c
// END of C:\206-3_11\devLibRlab\src\rlab.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\list.c
// END of C:\206-3_11\devLibRlab\src\list\list.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\lst.c
// END of C:\206-3_11\devLibRlab\src\list\lst.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\lstcell.c
// END of C:\206-3_11\devLibRlab\src\list\lstcell.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\lstidx.c
// END of C:\206-3_11\devLibRlab\src\list\lstidx.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\lstlc.c
// END of C:\206-3_11\devLibRlab\src\list\lstlc.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\lstld.c
// END of C:\206-3_11\devLibRlab\src\list\lstld.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\lststr.c
// END of C:\206-3_11\devLibRlab\src\list\lststr.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\obj.c
// END of C:\206-3_11\devLibRlab\src\list\obj.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\objfile.c
// END of C:\206-3_11\devLibRlab\src\list\objfile.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\rname.c
// END of C:\206-3_11\devLibRlab\src\list\rname.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\struct.c
// END of C:\206-3_11\devLibRlab\src\list\struct.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\list\table.c
// END of C:\206-3_11\devLibRlab\src\list\table.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\math\cpx.c
// END of C:\206-3_11\devLibRlab\src\math\cpx.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\math\elmath.c
// END of C:\206-3_11\devLibRlab\src\math\elmath.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\math\geom3D.c
/**
 * Creates a vtx list ie a list of (x,y,z) space coordinates or 3D vectors.
 * \a x \a y and \a z must be of type VTX CPX DOUBLE or LONG, scalar or of the same size
 * @param  x
 * @param  y optionnal replaced by 0.00
 * @param  z optionnal replaced by 0.00
 * @return v the vtx list
 * @note vtx function takes the three first value given to  x, y z. A vtx counts for 3 and a cpx for 2.
 * @endnote
 *      vtx(1,2,3)
 *      vtx(1,,0,lin(1,3)) = vtx(cpx(1,0),lin(1,3)) = vtx(1,cpx(0,lin(1,3))) = vtx(vtx(1,,0,lin(1,3))) = vtx(cpx(1,0),lin(1,3),666)
 */
v vtx( void x,  void y,  void z) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=59

/**
 * A shortcut function for vtx(1,0,0).
 * @return v
 */
v vtxEX() {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=131

/**
 * A shortcut function for vtx(0,1,0).
 * @return v
 */
v vtxEY() {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=143

/**
 * A shortcut function for vtx(0,0,1).
 * @return v
 */
v vtxEZ() {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=155

/**
 * Genenate a 3x3 rotation matrice around vtx(1,0,0) vector.
 * alplha is the radian angular value of type double.
 * @param  alpha
 * @return mat3 a 9 coeficient matrice 3x3 of type rot3mat
 */
mat3 rot3X( void alpha) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=312

/**
 * Genenate a 3x3 rotation matrice around vtx(0,1,0) vector.
 * alplha is the radian angular value of type double.
 * @param  alpha
 * @return mat3 a 9 coeficient matrice 3x3 of type rot3mat
 */
mat3 rot3Y( void alpha) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=329

/**
 * Genenate a 3x3 rotation matrice around vtx(0,0,1) vector.
 * alplha is the radian angular value of type double.
 * @param  alpha
 * @return mat3 a 9 coeficient matrice 3x3 of type rot3mat
 */
mat3 rot3Z( void alpha) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=346

/**
 * Genenate a 3x3 rotation matrice around the vector given.
 * alplha is the radian angular value of type double.
 * @param  v
 * @param  alpha
 * @return mat3 a 9 coeficient matrice 3x3 of type rot3mat
 * @note
 * v is normalized before being uses.
 */
mat3 rot3V( void v,  void alpha) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=363

/**
 *Display a 3x3 rotation.
 * @param mat3 a 9 coeficient matrice 3x3 of type rot3mat
 * @note
 * For debug pupose only.
 */
rot3_disp( void mat3) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=390

/**
 * Product of two 3x3 rotation matrice.
 * @param  r1 a 9 coeficient matrice 3x3 of type rot3mat
 * @param  r2 a 9 coeficient matrice 3x3 of type rot3mat
 * @return r  a 9 coeficient matrice 3x3 of type rot3mat
 * @note
 * a tranformation is ever simplify in v = vtx_add(vtx_rot(R,v),T)
 * simplifaication rules
 *      vtx_add(vtx_add(vtx_rot(R,v),T1),T2) => vtx_add(vtx_rot(R,v),T)  T=vtx_add(T1,T2)
 *      vtx_rot(R2,vtx_add(vtx_rot(R1,v),T1) => vtx_add(vtx_rot(R,v),T)  R=rot3_prod(R2,R1)  T=vtx_rot(R1,T1)
 */
r rot3_prod( void r1,  void r2) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=405

/**
 * Rotate a vtx list according to the given rotation matrice.
 * @param  R  a 9 coeficient matrice 3x3 of type rot3mat
 * @param  v  a list of vector
 * @return rv the rotated list
 * @note
 * see rot3_prod for composition.
 */
rv vtx_rot( void R,  void v) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=437

/**
 * Element by element sum between two vtx list.
 * @param  v1 a list of vector
 * @param  v2 a list of vector
 * @return rv the summed list.
 * @note
 * v1 or v2 could be of size 1.
 * compute rv = v1+v2
 */
rv vtx_add( void v1,  void v2) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=474

/**
 * Element by element subtraction between two vtx list.
 * @param  v1 a list of vector
 * @param  v2 a list of vector
 * @return rv the subtrcated list.
 * @note
 * v1 or v2 could be of size 1.
 * compute rv = v1-v2
 */
rv vtx_sub( void v1,  void v2) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=512

/**
 * Negated a list of vtx vector.
 * @param  v1 a list of vector
 * @return rv the summed list.
 * @note
 * compute rv = vtx(0,0,0) - v1
 */
rv vtx_neg( void v1) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=550

/**
 * Element by element cross product between two vtx list.
 * The crossProduct compute the normal vector of the two given vectors.
 * @param  v1 a list of vector
 * @param  v2 a list of vector
 * @param  v3 a list of vector (optional)
 * @return rv the cross product list (type vtx).
 * @note
 * v1,v2 or v3 could be of size 1.
 * crossProduct(v1,v2,v3) = crossProduct(v2-v1,v3-v1)
 */
rv vtx_crossProd( void v1,  void v2,  void v3) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=578

/**
 * Element by element scalar product between two vtx list.
 * @param  v1 a list of vector
 * @param  v2 a list of vector
 * @param  v3 a list of vector (optional)
 * @return rv the scalar product list (type double).
 * @note
 * v1,v2 or v3 could be of size 1.
 * scalarProduct(v1,v2,v3) = scalarProduct(v2-v1,v3-v1)
 */
rv vtx_scalarProd( void v1,  void v2,  void v3) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=652

/**
 * Element by element product between a list of vtx and a list of double.
 * @param  v1 a list of vector or a list of real
 * @param  v2 a list of real or a list of vector
 * @return rv the product list (type vtx).
 * @note
 * double x double or vtx x vtx will generate an error.
 * @endnote
 * vtx_realProd(vtx(1,2,3),2) = vtx(2,4,6)
 */
rv vtx_realProd( void v1,  void v2) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=711

/**
 * Element by element normalisation of a list of vector.
 * @param  v1 a list of vector
 * @return rv a list of vector, each of euclidean lenght 1.
 * @note
 * double x double or vtx x vtx will generate an error.
 * @endnote
 * compute rv = v / abs(v)
 * zero and nan vector will return vtxEZ=vtx(0,0,1)
 */
rv vtx_normalize( void v1) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=801

/**
 * Element by element norms of a list of vector.
 * @param  v1 a list of vector
 * @return rv a list of double.
 * @note
 * @endnote
 * compute v = sqrt( v.x*v.x  +  v.y*v.y  +  v.z*v.z)
 */
rv vtx_abs( void v1) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=846

/**
 * Element by next element differnce of a list of vector.
 * @param  v1 a list of vector
 * @return rv a list of vector.
 * @note
 * rv is of size=size(v1)-1
 * @endnote
 * vtx_diff(vtx([1,2,4,7,11])) = vtx([1,2,3,4])
 */
rv vtx_diff( void v1) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=879

/**
 * Element by next element differnce of a list of vector.
 * @param  v1 a list of vector
 * @return rv a list of vector.
 * @note
 * rv is same size as v
 * this is the left difference, fist point is extrapolate by second point value.
 * @endnote
 * vtx_diffL(vtx([1,2,4,7,11])) = vtx([1,1,2,3,4])
 */
rv vtx_diffL( void v1) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=909

/**
 * Element by next element differnce of a list of vector.
 * @param  v1 a list of vector
 * @return rv a list of vector.
 * @note
 * rv is same size as v
 * this is the left difference, last point is extrapolate by last but not least point value.
 * @endnote
 * vtx_diffR(vtx([1,2,4,7,11])) = vtx([1,2,3,4,4])
 */
rv vtx_diffR( void v1) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=950

/**
 * next element by previous element differnce of a list of vector.
 * @param  v1 a list of vector
 * @return rv a list of vector.
 * @note
 * rv is same size as v
 * first and last point are exprapolated as diffL and diffR.
 * vtx_diffLR = vtx_diffL + vtx_diffR
 * @endnote
 * vtx_diffLR(vtx([1,2,4,7,11])) = vtx([2,3,5,7,8])
 */
rv vtx_diffLR( void v1) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\math\geom3D.c li=990

// END of C:\206-3_11\devLibRlab\src\math\geom3D.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\math\interval.c
// END of C:\206-3_11\devLibRlab\src\math\interval.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\math\polygon.c
// END of C:\206-3_11\devLibRlab\src\math\polygon.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\math\polygonX.c
// END of C:\206-3_11\devLibRlab\src\math\polygonX.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\rtl\consdrv.c
// END of C:\206-3_11\devLibRlab\src\os\rtl\consdrv.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\rtl\ftdi.c
// END of C:\206-3_11\devLibRlab\src\os\rtl\ftdi.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c
/**
 * @addtogroup rlab_services
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=7

/**
   Exit app
   @param exit code *long*
*/
exit( void exit) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2575

/**
   top
*/
top() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2595

/**
   @internal
   * To Be Written.
   * @return ?
   */
UNK alm() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2644

/**
   @internal
   * To Be Written.
   * @param s *L.char*
   * @return ?
   */
UNK kill( void s) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2672

/**
   Clear console
*/
clc() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2692

/**
   display thread list
*/
scp() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2705

/**
   log thread list
*/
scp_log() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2716

/**
   @internal
   * Save the current console buffer into a text file.
   * *name* is the name of the file. If no name is provided "console.txt" will be used.
   * @param name *L.char*
   */
saveConsole( void name) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2767

/**
   @internal
   * Switch screen from user to console
   * @param yes
   */
affConsole( void yes) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2823

/**
 * Launch/Relaunch the console server on the given port.
 * @param port
 */
vtSetTcp_serverPort( void port) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2841

/**
 * Set the ip/port for a specifiv maj+FnVt page number.
 * @param nVt
 * @param ip_port_string (char)
 */
vtSetTcp_nVtIp( void nVt,  void ip_port_string) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2854

/**
 * Switch to another VT. Same has keyboard maj+Fn
 * @param nVt
 */
vtSwitch( void nVt) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2869

/**
 * Calculate md5 sum of a file.
 * @param fname *L.char*
 * @return md5hex *L.char*
 */
md5hex md5( void fname) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2882

/**
 * Calculate md5 sum of a string.
 * @param str *L.char*
 * @return md5hex *L.char*
 */
md5hex smd5( void str) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2947

/**
 * Calculate md5 sum of an object.
 * @param obj
 * @return md5hex *L.char*
 */
md5hex objMd5( void obj) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c li=2970

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\os\rtl\osrtl.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\rtl\serdrv.c
// END of C:\206-3_11\devLibRlab\src\os\rtl\serdrv.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\win\appLoaderLib.cpp
/**
 * Return the kiwi release String.
 * @return vers  (L.char)
 */
vers appRelease() {}
//level=0 fn=C:\206-3_11\devLibRlab\src\os\win\appLoaderLib.cpp li=46

/**
 * Read a release header file.
 * @param  fname (L.char)
 * @return vers  (L.char)
 */
vers readRelease( void fname) {}
//level=0 fn=C:\206-3_11\devLibRlab\src\os\win\appLoaderLib.cpp li=59

// END of C:\206-3_11\devLibRlab\src\os\win\appLoaderLib.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\win\oscmd.c
/**
 * @addtogroup rlab_services
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=13

/**
   Quit application.
   @param exit code *long*
 */
exit( void exit) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=18

/**
 * Disp loaded script runtime.
 * For debug purpose.
 */
scp() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=30

/**
 log thread list
 */
scp_log() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=41

/**
 * @internal
 * Compile  scripts into a single binary file.
 * No linkage is made.
 * @param lst_src (L2.char)
 * @param dst a string.
 * @param vspace
 * @param symFile
 */
compileLib( void lst_src,  void dst,  void vspace,  void symFile) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=53

/**
 * @internal
 * Load script libraries.
 * (*) lname = {'toto.app'};
 * (*) lname = { 'toto.app', 'tata.app' };
 * @param lname a list of string.
 */
loadLib( void lname) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=82

/**
 * @internal
 * compile scripts into a single binary file and check if linkage will be ok.
 * @param lst_src (L2.char)
 * @param lst_lib (L2.char)
 * @param sym *L.char*
 * @param dst *L.char*
 * @param vspace
 */
compileApp( void lst_src,  void lst_lib,  void sym,  void dst,  void vspace) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=98

/**
 * @internal
 * cross compile a pref file.
 * @param lst_file *L.char*
 * @param sym *L.char*
 * @return scp (script)
 */
scp compilePrefCross( void lst_file,  void sym) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=123

/**
 * Executes an internal operating system command.
 * @param cmd *L.char* argument string passed to the command interpreter
 */
system( void cmd) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oscmd.c li=140

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\os\win\oscmd.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\win\osconsole.c
// END of C:\206-3_11\devLibRlab\src\os\win\osconsole.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\win\oswin.cpp
/**
 * @addtogroup rlab_console
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oswin.cpp li=21

/**
 * @}
 * @addtogroup rlab_builtin_fun
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oswin.cpp li=447

/**
 * Return the current time since EPOC in second.
 * The result is in double format whith milisecond resolsution.
 * @return tps *double*
 */
tps ftime() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oswin.cpp li=454

/**
 * @}
 * @addtogroup rlab_file
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oswin.cpp li=470

/**
 * Full path of the current app directory.
 * @return path *L.char*
 */
path appDir() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oswin.cpp li=476

/**
 * Calculate md5 sum of a file.
 * @param fname *L.char*
 * @return md5hex *L.char*
 */
md5hex md5( void fname) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oswin.cpp li=496

/**
 * Calculate md5 sum of a string.
 * @param str *L.char*
 * @return md5hex *L.char*
 */
md5hex smd5( void str) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oswin.cpp li=562

/**
 * Calculate md5 sum of an object.
 * @param obj
 * @return md5hex *L.char*
 */
md5hex objMd5( void obj) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\oswin.cpp li=586

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\os\win\oswin.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\os\win\winserial.c
/**
 * @addtogroup Utils
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\winserial.c li=21

/**
 @internal
 * err=setSerialRTS(com,val)
 *     com = integer from 1 to N (com1 to comN)
 *     val : RTS = val!=0;
 */
setSerialRTS() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\winserial.c li=900

/**
 @internal
 * err=setSerialDTR(com,val)
 *     com = integer from 1 to N (com1 to comN)
 *     val : DCD = val!=0;
 */
setSerialDTR() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\winserial.c li=915

/**
  Performs an operation on a specified file.
  @param operation a verb, that specifies the action to be performed. The set
  of available verbs depends on the particular file or folder. Generally, the
  actions available from an object's shortcut menu are available verbs. The
  following verbs are commonly used: 'edit', 'explore', 'find', 'open', 'print'
  @param file
  @param parameters parameters to be passed to the application
  @param directory the default (working) directory for the action
  @param showFlag Show option for the opened window (0 to show normal, 1 to show unactive, 2 to hide)
 */
msShellExecute( void operation,  void file,  void parameters,  void directory,  void showFlag) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\winserial.c li=931

/**
  Performs an operation on a specified file. Waits for the operation to finish !!

  @param operation a verb, that specifies the action to be performed. The set
  of available verbs depends on the particular file or folder. The verbs
  currently supported are open and explore
  @param file
  @param parameters parameters to be passed to the application
  @param directory the default (working) directory for the action
  @param showFlag Show option for the opened window (0 to show normal, 1 to show unactive, 2 to hide)
 */
msShellExecuteEx( void operation,  void file,  void parameters,  void directory,  void showFlag) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\winserial.c li=1046

/**
 @internal
 * change file attributes to READONLY
 * return 0 of an error occues.
 * @param file path
 */
msSetFileReadOnly( void file) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\winserial.c li=1135

/**
 @internal
 * change file attributes to NORMAL
 * return 0 of an error occues.
 * @param file path
 */
msSetFileNormal( void file) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\winserial.c li=1155

/**
 @internal
 * Return a volume serial number.
 * This number change each time the disk is forlated.
 * return 0 of an error occues.
 * @param path
 * @return sn
 */
sn msGetVolumeSn( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\os\win\winserial.c li=1171

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\os\win\winserial.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\script\fncDateFile.c
/**
   @addtogroup rlab_builtin_fun
   @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=17

/**
   Give elapsed secondes since 1970
   @return time *long*
 */
time time() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=22

/**
   Print elapsed time in seconde as '170h26m' or '0m'
   @param tps *long*
   @param format *long* 0 -> ISO 8601. 1 -> default
   @return str *L.char*
 */
str sprintHM( void tps,  void format) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=34

/**
   Print elapsed time in seconde as '170h26m25s' or '0s'
   @param tps *long*
   @param format *long* 0 -> ISO 8601. 1 -> default
   @return str *L.char*
 */
str sprintHMS( void tps,  void format) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=59

/**
   print elapsed time in seconde as '17d00h26m' or '0m'
   @param tps *long*
   @return str *L.char*
 */
str sprintDHM( void tps) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=84

/**
   Print elapsed time in seconde as '17d02h26m25s' or '0s'
   @param tps *long*
   @param format *long* 0 -> ISO 8601. 1 -> default
   @return str *L.char*
 */
str sprintDHMS( void tps,  void format) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=100

/**
   Format time as given by time() according to fmt
   fmt=[] or '' is same as '\%a \%b \%d \%H:\%M:\%S \%Y'
   @param fmt format, accepted tokens :
       - \%a    -- day name (`Sun`)
       - \%A    -- day name (`Sunday`)
       - \%b    -- month name  (`Jan`)
       - \%B    -- month name (`January`)
       - \%c    -- std represenation date & time
       - \%d    -- day 01 31
       - \%H    -- hour 00 23
       - \%I    -- hour 01 12
       - \%j    -- day number (001-366)
       - \%M    -- minute 00 59
       - \%m    -- month 01 12
       - \%p    -- am pm
       - \%S    -- second 00 60
       - \%U    -- week number (Sunday as the first day) 00 53
       - \%u    -- day number/week (Monday as the first day of the week) 1 7
       - \%W    -- week number (Monday as the first day) 00 53
       - \%w    -- week number (Sunday as the first day) 0 7
       - \%X    -- national representation of the time (e.g., `23:13:48`)
       - \%x    -- national representation of the date (e.g., `12/31/99`)
       - \%Y    -- year 1970 2053
       - \%y    -- year 00 99
       - \%Z    -- time zone name
       - \%z    -- time zone offset from UTC
   @param tps *long*
   @return str *L.char*
 */
str sprintDate( void fmt,  void tps) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=124

/**
   Compute elapse time in seconde since 1970 to d=day(31)  m=monyh(12)  y=year(2007)
   @param d *long*
   @param m *long*
   @param y *long*
   @return t *long*
 */
t jma2time( void d,  void m,  void y) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=166

/**
   Compute start and stop time of current trimester.
   01 jan 0h00 -> 31 mar 23h59
   01 apr 0h00 -> 30 jun 23h59
   01 jul 0h00 -> 30 sep 23h59
   01 oct 0h00  -> 31 dec 23h59
   @param currtime *long*
   @return trim *L.long* [ts,te] start and end dates
 */
trim trimestre( void currtime) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=191

/**
   To Be Written.
   @return ltic *long*
 */
ltic tic() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=232

/**
   To Be Written.
   @return toc *long*
 */
toc toc() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=248

/**
   To Be Written.
   @return lTIC *long*
 */
lTIC TIC() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=264

/**
   To Be Written.
   @return lTOC *long*
 */
lTOC TOC() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=280

/**
   To Be Written.
   @return osclk *long*
 */
osclk osClk() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=296

/**
   To Be Written.
   @return osclkhz *long*
 */
osclkhz osClkHz() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=307

/**
   To Be Written.
   @return fosClkhz dbl
 */
fosClkhz fosClkHz() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=318

/**
   To Be Written.
   @return tick *long*
 */
tick osTick() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=329

/**
   To Be Written.
   @return r *long*
 */
r osTickHz() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=340

/**
   To Be Written.
   @return r dbl
 */
r fosTickHz() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=351

/**
   @}
   @addtogroup rlab_file
   @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=366

/**
   Return or disp the current working path.
   @return path *L.char*
 */
path pwd() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=373

/**
   Change current path.
   0 = no error
   @param path *L.char*
   @return err *long*
 */
err cd( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=394

/**
   Expand or clean up the given path.
   @param path *L.char*
   @return npath *L.char*
 */
npath fullpath( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=412

/**
   Return the directory part of the path.
   @param path *L.char*
   @return npath *L.char*
 */
npath dirpart( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=425

/**
   Return the name of the file.
   @param path *L.char*
   @return name *L.char*
 */
name filepart( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=442

/**
   Return 1 if the path is an existing directory.
   @param path *L.char*
   @return bool *long*
 */
bool isdir( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=458

/**
   Return 1 if the path is an existing file.
   @param path *L.char*
   @return bool *long*
 */
bool isfile( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=471

/**
   Creat a new directory.
   @param path *L.char*
   @return err *long*
 */
err mkdir( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=484

/**
   Delete a file.
   @param path *L.char*
   @return ok *long*
 */
ok rm( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=497

/**
   Delete a folder.
   @param path *L.char*
   @return ok *long*
 */
ok rmDir( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=510

/**
   Rename/move a file or a directory.
   @param f1 *L.char*
   @param f2 *L.char*
   @return err? *long*
 */
UNK renamefile( void f1,  void f2) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=523

/**
    Copies file1 to file2, returning 1 if successful.

    If overwrite parameter is 1 (default), the destination file is overwritten if it exists, but if overwrite is 0, the functions fails in this case.
    @param file1 *L.char*
    @param file2 *L.char*
    @param overwrite *long*
    @return 1/0 *long*
 */
UNK copyfile( void file1,  void file2,  void overwrite) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=539

/**
   Return or print files and directories of the given path.
   File may be filter ie 'r*.dat'
   @param path *L.char*
   @return file (L2.char)
   @return dir (L2.char)
 */
file dir ls( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=559

/**
   Return the modification date of the file.
   @param path *L.char*
   @return ctime *long*
 */
ctime filedate( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=618

/**
   Return the size left on the path (Ko).
   @param path *L.char*
   @return sz_kb *long*
 */
sz_kb getDiskSpace( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=632

/**
   Return the version tag
   @return vers *L.char* vX.X.X or vX.X.X+ EXPERIMENTAL
 */
vers scmVersionInfo() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=654

/**
   Return the version tag
   @return vers *L.char* vX.X.X only
 */
vers scmVersion() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=667

/**
   r=filesep();
   return the current os dependent file sep ie '/' or '\\'
   @param
   @return
 */
UNK filesep( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=684

/**
   Concateate path and add/correct filesep if needed.
   @param path0 *str*
   @param path1 *str*
   @param ...
   @return path *str*
 */
path fnameConc( void path0,  void path1,  void ...) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=702

/**
   Extract file extension from a path.
   "dir/fname.ext" => ".ext"
   "dir/fname.old.ext" => ".ext"
   "dir.O/fname.old.ext" => ".ext"
   "dir.O/fname" => ""
   @param path *str*
   @return ext *str*
 */
ext fnameExt( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=736

/**
   Extract file name.ext from a path.
   "dir/fname.ext" => "fname.ext"
   "dir/fname.old.ext" => "fname.ext"
   "dir.O/fname.old.ext" => "fname.old.ext"
   "dir.O/fname" => "fname"
   "dir.O/" => ""
   @param path *str*
   @return nameExt *str*
 */
nameExt fnameNameExt( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=753

/**
   Extract file name without .ext from a path.
   "dir/fname.ext" => "fname"
   "dir/fname.old.ext" => "fname.old"
   "dir.O/fname.old.ext" => "fname.old"
   "dir.O/fname" => "fname"
   "dir.O/" => ""
   @param path *str*
   @return name *str*
 */
name fnameName( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=771

/**
   Extract dir part ending with filesep from a path.
   "dir/fname.ext" => "dir/"
   "dir.O/fname.old.ext" => "dir.O/"
   "dir" => ""
   @param path *str*
   @return dirs *str*
 */
dirs fnameDirs( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=789

/**
   Break a path.
   "dir0/dir1/fname.ext" => { "dir0", "dir1" ,"fname" }
   "fname" => { "fname" }
   "" => { "" }
   @param path *str*
   @return epath (cell)
 */
epath fnameBreak( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=807

/**
   Create a path, ie creates all directories in the path.
   generate an error if it's failed to do the job.
   @param path *str*
 */
mkPath( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=822

/**
   write binary data into a file.
   Use a real thread.
   @param name
   @param data
 */
writeFile( void name,  void data) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=990

/**
   read binary data from a file.
   Use a real thread.
   @param name
   @return data
 */
data readFile( void name) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1061

/**
   save obj in file name (fast uncompressed format).
   @param name
   @param obj
 */
save( void name,  void obj) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1116

/**
   save obj in a buffer (fast uncompressed format).
   @param obj
   @return buff
 */
buff saveBuff( void obj) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1130

/**
   saveGz('name',obj);
   save obj in file name (slow compressed format)
   @param
   @return
 */
UNK saveGz( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1145

/**
   Save text string in file name
   @param filename *str*
   @param content *str*
   @return
 */
UNK saveText( void filename,  void content) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1166

/**
   Append some text to an exiting file, or create new file with some text.
   generate an error if it's failed to do the job.
   @param name *L.char*  name of the file
   @param string *L.char*  text to append to the file.
   @param fcreatPath (long,=0) if not null creates the file path if it does'nt exits.
   @return err *long*  0=ok.
 */
err appendText( void name,  void string,  void fcreatPath) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1183

/**
   Create a path, ie creates all directories in the path.
   generate an error if it's failed to do the job.
   @param path *str*
 */
createPath( void path) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1215

/**
   Read the filename as a text file
   @param name *L.char*
   @return str *L.char*
 */
str readText( void name) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1228

/**
  Read the filename as a csv file
  @param name *L.char*
  @param flag bool convert commas to dots if \c 1
  @return str *L.char*
*/
str readCSV( void name,  void flag) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1242

/**
 * Write the filename as a csv file.
 * @param fileName *L.char*
 * @param content *cell*
 */
writeCSV( void fileName,  void content) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1268

/**
   Read the file saved by save or saveGz.
   @param name
   @return obj
 */
obj load( void name) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1309

/**
   Read a raw buffer saved by saveBuff.
   @param buff
   @return obj
 */
obj loadBuff( void buff) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1323

/**
   obj = loadUntyped('name');
   read the file saved by save or saveGz.
   c-struct type are changed in varspc.
   Use if the c-type description has changed.
   @param name
   @return obj
 */
obj loadUntyped( void name) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1339

/**
   @}
   @addtogroup rlab_comm
   @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1358

/**
   Open a serial port.
   comDesc = 'com1';
   comDesc = "eth://IP/com";
   comDesc = "ftdi:/COM";
   optional comDesc = "COM_AS_ABOVE:BAUD"
   optional comDesc = "COM_AS_ABOVE:BAUD:FLAG1:FLAG2:...:FLAGN"
   optional comDesc = "COM_AS_ABOVE::FLAG1:FLAG2:...:FLAGN"
   - where FLAG = NOPARITY|EVEN|ODD                       [default:noparity]
   - where FLAG = 7BITS|8BITS                             [default:8bits]
   - where FLAG = STPONE|STPONE5|STPTWO                   [default:stpone]
   - where FLAG = DOERR  (do error if could not open com) [default:return 0]
   - where FLAG = SILENT (no printf)                      [default:verbose]
    optional arg comDef is a default configuation to complete the first definition.
   @param comDesc *L.char*
   @param comDef *L.char*
   @return iddrv *long*
 */
iddrv serOpen( void comDesc,  void comDef) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1364

/**
   Close an open serial port.
   @param idserial *long*
 */
serClose( void idserial) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1393

/**
   Put data on an open serial port.
   @param idserial *long*
   @param data *L.char*
 */
serPut( void idserial,  void data) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1405

/**
   Get data from an open serial port.
   @param idserial *long*
   @return data *L.char*
 */
data serGet( void idserial) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1428

/**
   Disp debug information about opened serial port.
 */
serInfo() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncDateFile.c li=1454

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\script\fncDateFile.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\script\fncMath.c
/**
 * @addtogroup rlab_math
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=8

/**
 * Approximation par les moindres carres.
 * Donne une approximation par les moindres carres du nuage de points z par une droite affine a*x+b
 * Monimise l'erreur selon y.
 * @param z
 * @retval a *double* pente de la droite
 * @retval b *double* offset de la droite z.im = a*z.re+b
 * @retval err dbl qualite de l'approximation (racine carre de la moyenne des carre des erreurs)
 */
a b err Arms( void z) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=16

/**
 * Approximation par les moindres carres.
 * Donne une approximation par les moindres carres du nuage de points z par une droite
 * Minimise l'erreur de projection euclidienne du nuage de point sur la droite.
 * @param z
 * @retval z0 *cpx* barycentre du nuage de points
 * @retval alpha dbl vecteur directeur qui minimise la droite (dans [-pi/2,pi/2])
 * @retval err dbl qualite de l'approximation (racine carre de la moyenne des carre des erreurs)
 */
z0 alpha err Drms( void z) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=47

/**
 * Approximation par les moindres carres.
 * Donne une approximation par les moindres carres du nuage de points z par une droite
 * Minimise l'erreur de projection euclidienne du nuage de point sur la droite.
 * @param z
 * @retval z0 *cpx* barycentre du nuage de points
 * @retval alpha dbl vecteur directeur qui minimise la droite (dans [-pi/2,pi/2])
 * @retval err dbl qualite de l'approximation (racine carre de la moyenne des carre des erreurs)
 * @retval lamdaMax dbl Plus grande valeur propre du nuage de point ( permet de mesurer sont tendu dans la plus grande direction)
 */
z0 alpha err lamdaMax Drms2( void z) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=79

/**
 * Approximation par les moindres carres, ajout de points.
 * @param rmsData TdrmsData ongoing statistics
 * @param z *L.cpx* new points
 * @return rmsData (empty if no argument given)
 */
rmsData addDrms( void rmsData,  void z) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=118

/**
 * Approximation par les moindres carres, suppression de points.
 * @param rmsData TdrmsData ongoing statistics
 * @param z *L.cpx* points to suppress
 * @return rmsData
 */
rmsData subDrms( void rmsData,  void z) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=153

/**
 * Approximation par les moindres carres, statistique sur les points en cours.
 * @param rmsData TdrmsData ongoing statistics
 * @param z0 *cpx* points cloud barycenter
 * @param alpha dbl vecteur directeur qui minimise la droite (dans [-pi/2,pi/2])
 * @param err qualite de l'approximation (racine carre de la moyenne des carre des erreurs)
 */
getDrms( void rmsData,  void z0,  void alpha,  void err) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=190

/**
 * Approximation de nuage de points.
 * @param z
 * @param m
 * @return z0
 * @return alpha
 * @return err
 */
z0 alpha err Prms( void z,  void m) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=226

/**
  Donne une approximation par les moindres carres du nuage de points z par un cercle
  @param z *L.cpx* data points
  @retval zo *cpx* circle center
  @retval dbl circle radius

  @code
   z = cpx(rand(4),rand(4));
   [z0,R] = Crms(z);
   zoom(axes(win,'equal',1));
   plot(z,'rxe ');
   plot(z0+R*iexp(lin(0,40)*(pi/20)),'b+');
  @endcode
 */
zo dbl Crms( void z) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=260

/**
  Calcule l'enveloppe convexe d'un nuage de points z.
  Si ind est passe, il designe un sous ensemble de z.
  @param z *L.cpx*
  @param ind *L.long*
  @return ind_env *L.long*
  @note z.(ind) Doit etre classe selon re puis im croissant.
          ie `ind = isort(z,strn('re','im'));`
          z.(ind_env) est un polygone positif.
 */
ind_env envConvex( void z,  void ind) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=294

/**
  Calcul des rectangles entourant un nuage de points z.
  Si ind est passe, il designe un sous ensemble de z.
  @param z *L.cpx*
  @param ind *L.long*
  @return lrect *L.geoPara*
  @note z.(ind) Doit etre classe selon re puis im croissant.
          ie `ind = isort(z,strn('re','im'));`
          z.(ind_env) est un polygone positif.
 */
lrect envRect( void z,  void ind) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=316

/**
  Simplifie un parallelogramme.
  geoPara.a sera alors le plus grand (re, puis im si egalite)
  @param lgeoPara *L.geoPara*
  @return res *L.cpx*
 */
res geoParaSimple( void lgeoPara) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=336

/**
  Calcul les contours d'une liste de parallelogrammes.
  @param lgeoPara *L.geoPraa*
  @return res *L.cpx*
 */
res geoPara2cnt( void lgeoPara) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=352

/**
  Cree un polygone a partir de la liste de complexes.
  @param cnt *L.cpx* doit contenir au moins trois points et tre fermee.
  Il doit donc y avoir au moins 4 elements [a,b,c,a]
  @return p
  @warning ne verifie pas la validite du polygone.
 */
p cnt2poly( void cnt) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=368

/**
  Localisation d'un point dans un polygone
  @param lst_z
  @param p Tpoly
  @return lst_bool with bool :
   -    *0*: exterieur
   -    *1*: interieur
   -    *2*: contour
   -    *3*: sommet
 */
lst_bool inpoly( void lst_z,  void p) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=390

/**
  Localisation d'un point dans une surface
  @param z *L.cpx*
  @param s *Tsurf*
  @return res *L.bool* with bool :
   -    *0*: exterieur
   -    *1*: interieur
   -    *2*: contour
   -    *3*: sommet
 */
res insurf( void z,  void s) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=436

/**
 * Surface d'un polygone
 * @param p T.poly
 * @return s dbl
 */
s polyS( void p) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=478

/**
 * Calcule la surface d'un contour oriente, ferme ou non.
 * @param cnt *L.cpx*
 * @return s dbl
 */
s cntCalcS( void cnt) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=498

/**
 * Surface d'une surface...
 * @param s Tsurf
 * @return s dbl
 */
s surfS( void s) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=512

/**
 * Centre de gravite d'un polygone
 * @param p Tpoly
 * @return zg *cpx*
 */
zg polyGs( void p) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=525

/**
 * Signe d'un polygone
 * @param p Tpoly
 * @return sg *long*
 */
sg polySign( void p) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=546

/**
 * deplace un polygogne
 * @param p Tpoly
 * @param dalpha dbl
 * @param dz *cpx*
 * @return p Tpoly
 */
p polyMove( void p,  void dalpha,  void dz) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=566

/**
 * Donne la distance du point au countour du polygone le plus proche
 * @param z *cpx*
 * @param p *Tpoly*
 * @return dist *double*
 */
dist polyDist( void z,  void p) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=594

/**
 * Donne la distance du point au countour du polygone le plus proche
 * @param z *cpx*
 * @param p *Tpoly*
 * @return res *L.long*
 *
 *   @verbatim
 *                         |                   |
 *                  3      |         4         |      5
 *             ------------/-------------------/------------
 *                  2      /        poly       /      6
 *             ------------/-------------------/------------
 *                  1      |         8         |      7
 *                         |                   |
 *   @endverbatim
 *
 * @code
 *
 * res = polyFindWhere(cpx(1.,2.), [poly1(),poly2(),...]);
 *
 * res = polyFindWhere(cpx(1.,2.), poly1());
 * @endcode
*/
res polyFindWhere( void z,  void p) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=622

/**
 * Calcule la surface union de deux surfaces
 * @param s1 Tsurf
 * @param s2 Tsurf
 * @param val dbl
 * @return s Tsurf
 */
s surfUnion( void s1,  void s2,  void val) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=668

/**
 * Calcul le polygone union de deux polygones.
 * @param p1 Tpoly
 * @param p2 Tpoly
 * @param val dbl
 * @return p Tpoly
 */
p polyUnion( void p1,  void p2,  void val) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=688

/**
  Compare deux polygones.
  @param p1 Tpoly
  @param p2 Tpoly
  @return long
   - \a -1 si deux polygones sont  disjoints
   - *0*  si p1==p2
   - *1* si p1 inclus dans p2
   - *2* si p2 inclus dans p1
   - *3* si p1 et p2 sont d'intersection non vide
*/
long polyCmp( void p1,  void p2) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=715

/**
  Validite d'un polygone.
  @param p Tpoly
  @return long
   - *0* : OK
   - *1* : pas assez de points
   - *2* : non ferme
   - *3* : deux points concecutifs superposes
   - *4* : contour croise
 */
long polyIsBad( void p) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=749

/**
  Verifie une surface
  @param s Tsurf
  @return long
   -    *0* : OK
   -    *1* : un des polygones a pas assez de points
   -    *2* : un des polygones est non ferme
   -    *3* : un des polygones a deux points concecutifs superposes
   -    *4* : un des polygones a des contour croise
   -    *10* : probleme de signe la surface +
   -    *11* : probleme de signe sur une surface -
   -    *12* : surface - incluse dans la surface +
   -    *13* : deux surfaces moins non disjointe
   -    *14* : plus de deux surface positive (ls->n!=1)
 */
long surfIsBad( void s) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=773

/**
 * Transforme une liste d'intervalles en une liste d'indexs
 * equivalents.
 * @param int Tinterval
 * @return index
 * @note un intervalle possede deux champs a et b et represente l'intervalle [a,b[
 */
index interval2index( void int) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=800

/**
 * Transforme une liste d'index en une liste d'intervalles equivalents.
 * @param index
 * @return int Tinterval
 * @note un intervalle possede deux champs a et b et represente l'intervalle [a,b[
 */
int index2interval( void index) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=817

/**
  Transforme une liste de booeleens en une liste d'intervalles equivalents.
  @param bool *L.long*
  @param borderInclude si !=0 alors on augmente/diminue la taille des
  intervalles, en tenant compte des limites liees aux dimensions de la liste bool.
  @return int
  @note un intervalle possede deux champs a et b et represente l'intervalle [a,b[
 */
int intervalFind( void bool,  void borderInclude) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=832

/**
 * Fusionne deux listes d'intervalles en supprimant les doublons.
 * @param interA
 * @param interB
 * @return inter
 * @note un intervalle possede deux champs a et b et represente l'intervalle [a,b[
 */
inter intervalUnion( void interA,  void interB) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=852

/**
 * Intersection de deux listes d'intervalles.
 * @param interA
 * @param interB
 * @return inter
 * @note un intervalle possede deux champs a et b et represente l'intervalle [a,b[
 */
inter intervalIntersection( void interA,  void interB) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=869

/**
 * Somme de la taille de chaque intervalle composant la liste.
 * @param inter
 * @return sz
 * @note un intervalle possede deux champs a et b et represente l'intervalle [a,b[
 */
sz intervalSize( void inter) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=885

/**
  Etudie l'intersection entre deux segments [ab] et [cd];
  @param a
  @param b
  @param c
  @param d
  @return long
   -    *0*: pas d'intersection
   -    *1*: intersection type L
   -    *2*: intersection type T
   -    *3*: intersection type X
   -    *4*: intersection d'interieur non vide
   -    *5*: segments egaux
  @note vectorisable
 */
long isInterSS( void a,  void b,  void c,  void d) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=902

/**
 * Calcul du point d'intersection entre deux droites (ab) et (cd);
 * @param a *cpx*
 * @param b *cpx*
 * @param c *cpx*
 * @param d *cpx*
 * @return z *cpx*
 */
z calcInterDD( void a,  void b,  void c,  void d) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1029

/**
 * Calcul du point d'intersection entre deux droites (a,capa) et (b,capb);
 * - Nan si droite egale
 * - Inf si droite parallele strictement.
 *
 * @param a
 * @param capa
 * @param b
 * @param capb
 * @return sa tel que zint = a + sa*exp(i*capa)
 * @note vectorisable
 */
sa calcInterDeDe( void a,  void capa,  void b,  void capb) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1136

/**
 * Calcul le determinant de deux vecteurs.
 * @note vectorisable
 * @param a
 * @param b
 * @return v
 */
v det( void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1248

/**
 * calcul le produit scalaire de deux vecteurs....
 * vectorisable
 * @param a
 * @param b
 * @return v
 */
v scal( void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1314

/**
 * Calcule la distance euclidienne entre deux points.
 * @param a *cpx*
 * @param b *cpx*
 * @return d dbl
 * @note vectorisable
 */
d dist( void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1380

/**
 * Calcule la distance du point z a la droite (ab)
 * @note vectorisable
 * @param z *cpx*
 * @param a *cpx*
 * @param b *cpx*
 * @return d dbl
 */
d distD( void z,  void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1447

/**
 * Calcul la distance du point z au segment [ab];
 * @param z *cpx*
 * @param a *cpx*
 * @param b *cpx*
 * @return d dbl
 * @note vectorisable
 */
d distS( void z,  void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1536

/**
 * Modulo angle dans ]-pi,pi]
 * @param x
 * @return y
 * @note vectorisable
 */
y mod1( void x) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1626

/**
 * Modulo angle dans [0,2*pi[
 * @param x
 * @return y
 * @note vectorisable
 */
y mod2( void x) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1657

/**
 * Calcul l'angle entre les vecteurs a et b ou calcul le cap du vecteur a
 * dans ]-pi,pi]
 * @param a
 * @param b optional
 * @return alpha dbl
 * @note vectorisable
 */
alpha ang1( void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1688

/**
 * Calcule l'angle entre les vecteurs a et b ou calcule le cap du vecteur a
 * dans [0,2*pi[
 * @param a
 * @param b optional
 * @return alpha
 * @note vectorisable
 */
alpha ang2( void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1769

/**
 * Calcule le cap d'un segment dans ]-pi,pi]
 * @param a
 * @param b
 * @return alpha
 * @note vectorisable
 */
alpha cap1( void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1850

/**
 * Calcule le cap d'un segment dans [0,2*pi[
 * @param a
 * @param b
 * @return alpha
 * @note vectorisable
 */
alpha cap2( void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1916

/**
 * Calcule la fonction cycloide
 * @param alpha
 * @return y
 * @note vectorisable
 */
y ff( void alpha) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=1983

/**
 * Calcule la fonction xycloide
 * @param alpha
 * @param k
 * @return y
 * @note vectorisable
 */
y xf( void alpha,  void k) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2015

/**
 * Calcule le point d'intersection de deux cercles.
 * @param zC0
 * @param zC1
 * @param R0
 * @param R1
 * @retval zI0
 * @retval zI1
 */
zI0 zI1 interCircle( void zC0,  void zC1,  void R0,  void R1) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2080

/**
 * Rotate coordinate from angle.
 * @param point
 * @param angle
 * @return Rotated point
 */
Rotated rotate( void point,  void angle) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2120

/**
 * Cree une table d'approximation cubique.
 * @param zp *cpx*
 * @param tmin dbl
 * @param tmax dbl
 * @return sp
 */
sp cubicSampleNew( void zp,  void tmin,  void tmax) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2146

/**
 * Calcul z=f(t) a partir d'une table d'approximation cubique.
 * @param sp
 * @param t dbl
 * @return z
 */
z cubicSampleCalc( void sp,  void t) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2167

/**
 * Sum of a vector
 * @param x
 * @return sum of the vector
 * @note implemented on LONG DOUBLE COMPLEX
 * @endnote
 *      sum([1,2,3]) => 6
 */
sum sum( void x) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2200

/**
 * Product of a vector
 * @param x
 * @return product of the vector
 * @note implemented on LONG DOUBLE COMPLEX
 * @endnote
 *      prod([1,2,3]) => 6
 */
product prod( void x) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2265

/**
 * Cumulative sum of a vector
 * @param x
 * @return cumsum
 *
 *          cumsum([1,2,3]) => [1,3,6]
 *
 * @note implemented on LONG DOUBLE COMPLEX
 */
cumsum cumsum( void x) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2332

/**
 * Return the differences between adjacent elements of x
 *
 * @param x
 * @return diff
 *
 * @note implemented on LONG DOUBLE COMPLEX
 * @endnote
 *
 *      diff([1,2,3]) => [1,1]
 *      diff(1) => [0xlong]
 *      diff([0xlong]) => Null
 */
diff diff( void x) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2396

/**
 * Return the mean value of a vector
 * @param x
 * @return mean
 *
 *      mean([1,2,3]) => 2.
 *
 * @note implemented on LONG DOUBLE COMPLEX
 */
mean mean( void x) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2463

/**
 * On connait `(z,cap)/R` et `Rm(zRm_R,capRm_R)/R`.
 * Calcul de `(zm,capm)/Rm` :
 * @param z
 * @param cap
 * @param zRm_R
 * @param capRm_R
 * @retval zm `= (z-zRm_R)*exp(-i*capRm_R)`
 * @retval capm `= cap-capRm_R`
 * @note examples :
    - pal/rob = repCompose(pal/MAP,MAP/rob)
    - map/rob = repICompose(PAL/rob,PAL/map)
    - pal/map = repChange(pal/ROB,map/ROB)
 */
zm capm repChange( void z,  void cap,  void zRm_R,  void capRm_R) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2534

/**
 * On connait `(zm,capm)/Rm` et `Rm(zRm_R,capRm_R)/R`.
 * Calcul de `(z,cap)/R`
 * @param zm
 * @param capm
 * @param zRm_R
 * @param capRm_R
 * @retval  z `= zm*exp(i*capRm_R) + zRm_R`;
 * @retval  cap `= capm+capRm_R`;
 * @note examples :
    - pal/rob = repCompose(pal/MAP,MAP/rob)
    - map/rob = repICompose(PAL/rob,PAL/map)
    - pal/map = repChange(pal/ROB,map/ROB)
 */
z cap repCompose( void zm,  void capm,  void zRm_R,  void capRm_R) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2579

/**
  On connait `(zm,capm)/Rm` et `(z,cap)/R`.
  Calcul `Rm(zRm_R,capRm_R)/R`
  @param z
  @param cap
  @param zm
  @param capm
  @retval zRm_R `= z - zm*exp(i*capRm_R)`
  @retval capRm_R `= cap-capm`
  @note examples :
    - pal/rob = repCompose(pal/MAP,MAP/rob)
    - map/rob = repICompose(PAL/rob,PAL/map)
    - pal/map = repChange(pal/ROB,map/ROB)
 */
zRm_R capRm_R repICompose( void z,  void cap,  void zm,  void capm) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2624

/**
 * @param lc  liste de complex dont lc.re croissant presque strictement
 * @param t *double* compris dans lc.re
 * @return v  approx lineaire dans le bon morceau de lc.im...
 */
v affineCalc( void lc,  void t) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2672

/**
 * @param lc  liste de complex dont lc.re croissant presque strictement
 * @param t *double* compris dans lc.re
 * @return v  approx lineaire dans le bon morceau de lc.im...
 */
v affineCalcCap( void lc,  void t) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2713

/**
 * Approximation lineaire dans le bon morceau de lc.im.
 * lc1 et lc2 liste de complexes dont lc.re est croissant presque strictement
 * @param lc1
 * @param lc2
 * @return lc1
 */
lc1 affineAdd( void lc1,  void lc2) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2755

/**
 * @param lc  liste de complex dont lc.re croissant strictement
 * @param zseg *list*e de deux conplexe
 * @param vmax valeur de saturation de zseg
 * @param ex erreur d'approximation selon x
 * @return lc (non reechantillonne)
 */
lc affineMaxSeg( void lc,  void zseg,  void vmax,  void ex) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2860

/**
 * @param lc *list*e de complex dont lc.re croissant strictement
 * @param zseg  liste de deux conplexe
 * @param vmin valeur de saturation de zseg
 * @param ex  erreur d'approximation selon x
 * @return lc (non reechantillonne)
 */
lc affineMinSeg( void lc,  void zseg,  void vmin,  void ex) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=2934

/**
 * Approx lineaire dans le bon morceuax de lc.im
 * @todo EN DEV
 * @param lc1
 * @param lc2
 * @return lc *list*e de complex dont lc.re croissant presque strictement
 *     @code
       affineMax(cpx([0,1],2),cpx([0,1],3)),
       affineMax(cpx([0,1,2,3],[1,-1,1,2]),cpx([0,3],0)),
       affineMax(cpx([0,1,2,3],[1,0,-1,2]),cpx([0,3],0)),
       affineMax(cpx([0,9],-1),cpx([0,4,4,5,5,9],[-1,-1,0,1,-1,-1])),
       @endcode
 */
lc affineMax( void lc1,  void lc2) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=3022

/**
 * lc = liste de complex dont lc.re croissant presque strictement
 * approx lineaire dans le bon morceau de lc.im...
 * @todo EN DEV
 * @param lc1
 * @param lc2
 * @return lc
 */
lc affineMin( void lc1,  void lc2) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=3189

/**
 * @todo To be Written.
 */
longFromShortF1() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=3350

/**
 * @todo To be Written.
 */
longFromShortF2() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=3370

/**
 * @todo To be Written.
 */
doubleFromFloat() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=3390

/**
 * @todo To be Written.
 */
cpxFromFloat() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=3414

/**
 * @todo To be Written.
 */
short2() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMath.c li=3446

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\script\fncMath.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\script\fncMathStd.c
/**
 * @addtogroup rlab_math
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=10

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=60

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=86

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=112

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=213

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=239

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=266

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=292

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=318

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=410

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=428

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=528

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=558

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=588

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=617

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=648

/**
 * To Be Written.
 * @param a
 * @param b
 * @return b
 */
b BADNAME( void a,  void b) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=678

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=710

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=728

/**
 * To Be Written.
 * @param
 * @return
 */
UNK BADNAME( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=746

/**
 * y=sin(x);
 * compute sinus in RADIAN
 * x should be double
 */
sin() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=835

/**
 * y=asin(x);
 * compute arcsinus in RADIAN
 * x should be double
 */
asin() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=858

/**
 * y=cos(x);
 * compute cosinus in RADIAN
 * x should be double
 */
cos() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=882

/**
 * y=acos(x);
 * compute cosinus in RADIAN
 * x should be double
 */
acos() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=906

/**
 * y=tan(x);
 * compute tangent in RADIAN
 * x should be double
 */
tan() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=931

/**
 * y=atan(x);
 * compute arc tangent in RADIAN
 * x should be double
 */
atan() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=955

/**
 * z=atan2(y,x);
 * compute arc tangent of y/x in RADIAN
 * x,y should be double
 */
atan2() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=978

/**
 * pi();
 * return 3.14159
 */
pi() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=994

/**
 * y = abs(x);
 * implemented on LONG DOUBLE COMPLEX
 */
abs() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1052

/**
 * y=rand;
 * y=rand(n);
 * return n random numbers (LONG) between 0 and RANDMAX=32767 (platform dependent)
 */
rand() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1076

/**
 * Set rand seed.
 * @param seed
 */
srand( void seed) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1103

/**
 * bool = isnan(x)
 * true if number is nan (ie 0./0.)
 * implemented on LONG DOUBLE COMPLEX
 */
isnan() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1116

/**
 * nan();
 * return nan number
 */
nan() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1170

/**
 * y = round(x)
 * round toward nearest int.
 * result is still double or cpx
 * round(1.1) => 1.0
 * implemented on LONG DOUBLE COMPLEX
 */
round() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1183

/**
 * y = ceil(x)
 * round toward next higher or equal int
 * result is still double or cpx
 * ceil(1.1) => 2.0
 * implemented on LONG DOUBLE COMPLEX
 */
ceil() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1229

/**
 * y = floor(x)
 * round toward previous smaller or equal int
 * result is still double or cpx
 * floor(1.1) => 1.0
 * implemented on LONG DOUBLE COMPLEX
 */
floor() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1275

/**
 * y=conj(x);
 * negate imaginary part of a complex number
 * implemented on LONG DOUBLE COMPLEX
 */
conj() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1321

/**
 * y = sign(x);
 * return 1,0 or -1 according to de sign...
 * type is unchanged!
 * implemented on LONG DOUBLE COMPLEX
 */
sign() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1355

/**
 * y = sqrt(x);
 * return the sqare root number
 */
sqrt() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1404

/**
 * y = sq(x); //ie y=x*x;
 * return the sqare  number
 */
sq() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1464

/**
 * y = ln(x);
 * return the natural logarithme number of double
 * implemented on DOUBLE only
 */
ln() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1523

/**
 * y = exp(x);
 * return the expodential number of double
 * implemented on DOUBLE only
 */
exp() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1547

/**
 * y = log10(x);
 * return the decimal logarithme number of double
 * implemented on DOUBLE only
 */
log10() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1572

/**
 * y = log2(x);
 * return the binary logarithme number of double
 * implemented on DOUBLE only
 */
log2() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1597

/**
 * y = exp10(x);
 * return the decimal expodential number of double
 * implemented on DOUBLE only
 */
exp10() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1621

/**
 * z = iexp(x);
 * return  z = exp(i*x) = cpx(cos(x),sin(x))
 * implemented on DOUBLE only
 */
iexp() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1645

/**
 * [val,ind] = min(num);
 * val = min(num1,num2);
 * return the minimum of a list and all the positions where it appears
 * OR return the minimum of two list, element by element
 * exemple:
 *  [a,b] = min([1,2,1,2]) => a=1 b=[0,2]
 *  a = min([1,2],[3,4])   => a=[1,2]
 * implemented on LONG and DOUBLE
 */
min() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1677

/**
 * [val,ind] = max(num);
 * val = max(num1,num2);
 * return the maximum of a list and all the positions where it appears
 * OR return the maximum of two list, element by element
 * exemple:
 *  [a,b] = max([1,2,1,2]) => a=2 b=[1,3]
 *  a = max([1,2],[3,4])   => a=[3,4]
 * implemented on LONG and DOUBLE
 */
max() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1763

/**
 * Power function
 *
 * pow(a,b)=a^b
  * @code
    a = pow(2,3) => a=8.
    a = pow([1,2,3],3) => a = [1^3,2^3,3^3] = [ 1.,8.,27. ]
    a = pow(2,[1,2,3]) => a = [2^1,2^2,2^3] = [ 2.,4.,8. ]
    a = pow([2,3,4],[3,4,5]) => a = [2^3,3^4,4^5] = [ 8.,81.,1024. ]
 * @endcode
 *
 */
pow() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\fncMathStd.c li=1847

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\script\fncMathStd.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\script\fncPrivate.c
/**
 * @addtogroup rlabkiwi
 * @{
 * @addtogroup rlab_statements
 * @{
 */
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=11

/**
 * return;
 * return from the current function
 */
return() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=47

/**
 * Give the last index of expr
 */
end() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=640

/**
 * Give all indexes of expr same as *lin(0,end)*
 */
all() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=680

/**
 * Set local var with global var value.
 * @param name name of global
 *
 *      global a('toto');
 *      global g(2)
 */
global( void name) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=729

/**
 * Set global var to the given varspc
 * Be careful 'name' should no be used by a local variable in any thread
 * @param name *strn*|int identifier
 * @param v *varspc*
 *
 *       setGlobal('name',varspc);
 *       setGlobal(id,varspc);
 */
setGlobal( void name,  void v) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=765

/**
 * Clear global variable 'name'
 * Be careful 'name' should no be used by a local variable in any thread
 * @param name *strn*|id identifier
 */
clearGlobal( void name) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=807

/**
 * Get a unique identifier starting at -1
 * @return long identifier
 */
long identifier() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=827

/**
 * Set local var to reference expr.
 * Be careful of write/read violations
 * @param expr expression to reference
 *
 *         ref panel(w->box->circ->pan)
 */
ref( void expr) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=840

/**
* Set local var to reference expr.
 * refVar a(varspc,field);
 * same as ref a(varspc->field);
 * Be carefull to write/read violation
 */
refVarspc() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=876

/**
 * To Be Written.
 */
BADNAME() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=981

/**
 * @internal
 * ->&
 * Utilisation (1) Rcuprer un objet volumineux sans copie (optimisation)
 * Utilisation (2) Faire des smaphores
 *
 * init : g->semaphore = 1;
 * use :
 *  while(isnull(g->&semaphore)) wait();
 *      //do stuff
 *   g->semaphore = 1;
 */
BADNAME() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1022

/**
 * Get varspc attribute
 * @param v *varspc*
 * @param field *strn* field name
 */
getVar( void v,  void field) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1245

/**
 * Edit varspc field
 * @param v *varspc*
 * @param field *strn* field name
 * @param obj field value
 * @warning varspc is passed by reference
 */
setVar( void v,  void field,  void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1297

/**
 * Check if a field is defined in the given varspc.
 * @param v *varspc*
 * @param name *strn*
 * @return true if name is a defined field of the varspc
 */
true isvar( void v,  void name) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1378

/**
 * Remove field from varspc
 * @param v *varspc*
 * @param field *strn* field name
 * @warning varspc is passed by reference
 */
varspcRemove( void v,  void field) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1413

/**
 * Create a varspc containing nth element of each list contained in given varspc.
 * @param v *L.varspc* varspc array to slice
 * @param k *long* index of the element of \a v to extract
 * @return v *varspc*  extracted varspc

 * Makes the code more readable when dealing with results of db requests eg
 * @code
 *  keys = DBgetAllKeys_gbl('palDB');
 *  paldata = DBget_gbl('palDB', keys);
 *  k = for(keys){
 *     p = sliceVarspc(paldata, k);
 *     // process p varspc infos...
 *  }
 * @endcode
 */
v sliceVarspc( void v,  void k) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1463

/**
 * Merge two varspc.
 * @param a *varspc*
 * @param b *varspc*
 * @warning varspc a is passed by reference
 */
mergeVarspc( void a,  void b) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1516

/**
 * 'if' conditional statement
 * @param bool
 */
if( void bool) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1541

/**
 * 'while' conditional statement
 * @param bool
 */
while( void bool) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1575

/**
 * 'else' conditional statement
 */
else() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1614

/**
 * 'continue' conditional statement
 */
continue() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1627

/**
 * 'break' conditional statement
 */
break() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1633

/**
 * To Be Written.
 */
BADNAME() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1643

/**
 * To Be Written.
 */
BADNAME() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1682

/**
 * To Be Written.
 * @param
 * @return
 */
UNK for( void UNK) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1765

/**
 * 'switch' conditional statement
 * @param p
 */
switch( void p) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1860

/**
 * 'case' conditional statement
 */
case() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1912

/**
 * 'default' conditional statement
 */
default() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1922

/**
 * 'try' conditional statement
 */
try() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1929

/**
 * 'catch' conditional statement
 */
catch() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1949

/**
 * 'droptry' conditional statement
 * @param p
 * @return r
 */
r droptry( void p) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=1965

/**
 * Execute critical code.
 *  @code
    unint expr;
    unint { expr1; expr1; }
 * @endcode
 */
unint() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\fncPrivate.c li=2107

//Kiwi auto close bracket!
/**
 * @}
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\script\fncPrivate.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\script\pref.c
/**
 * @addtogroup rlab_file
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\script\pref.c li=11

/**
  Load a text preference file.
  A text pref file is interpred like a command line.
  All variable defined will be present in the returned varspc.

  @code
    saveText('mypref.scp',"a=3;
   b=2;
   c='toto';
   d=sin(pi/3);
   e = c.(b);
   ");
   pref = loadPref('mypref.scp'),
   pref->d,

   returns :
   <console> pref = <
   a:3
   c:'toto'
   b:2
   e:'t'
   d:0.866025
   >
   <console> 0.866025
  @endcode

  @param filename a string containing a text file name path to be read.
  @return pref a varspc containing the list of variable defined in the file.
 */
pref loadPref( void filename) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\script\pref.c li=330

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\script\pref.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\script\scpfunc.c
/**
 * @addtogroup rlabkiwi
 * @{
 * @addtogroup rlab_builtin_types
 * @{
 */
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1

/**
 * Cre un nouveau type de liste.
 * @code
 * typedef('toto','a:long b:double c:L.char');
 * z = new('toto');
 * z.c{3} = '123';
 * @endcode
 *
 * @param name : nom du type
 * @param field_Desc : descriptif des types composant au format
 * 'nom1:type1 nom2:type2... '
 * @param isScal
 *
 * @note
 * - les types de base sont 'long' 'double' 'obj' 'cpx' 'L.char'
 * - les types composs sont les types precedement definis et 'L.xxx'
 *
 */
typedef( void name,  void field_Desc,  void isScal) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=14

/**
 * Affiche des informations sommaires sur un type
 * @param nom type demand
 */
typeinfo( void nom) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=62

/**
 * Return true if the list is of type long, double or cpx.
 * @param lst
 * @return bool *long*
 */
bool isNumeric( void lst) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=92

/**
 * Is object of given type?
 * @param object *object* to test
 * @param name type
 * @return b 1 if list elements are of type 'name', an error is generated if type does
 * not exist. NULL means "none type".
 */
b istype( void object,  void name) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=106

/**
 * Return the type of a list.
 * @param obj
 * @return type_str *L.char*
 */
type_str getType( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=127

/**
 * Create a new list of type \a type that contains \a n elements initialized at 0 and
 * preallocates \a nmax elements.
 * @code
 * a=new('cpx',7);
 * @endcode
 * @param type 'type'
 * @param n *list* size
 * @param nmax size to allocate
 */
new( void type,  void n,  void nmax) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=142

/**
 * Try to convert an obj into a long.
 * Implemented on CHAR LONG DOUBLE CPX(re)
 * @param obj
 * @return long
 */
long long( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=214

/**
 * Try to convert an obj into a string.
 * Implemented on CHAR LONG NAME.
 * @param obj
 * @return str
 */
str char( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=270

/**
 * Cast a flat object into a string.
 * @param obj
 * @return raw
 */
raw rawChar( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=321

/**
 * Cast a flat object into a long list.
 * @param obj
 * @return raw
 */
raw rawLong( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=347

/**
 * Cast a flat object into a double list.
 * @param obj
 * @return raw
 */
raw rawDouble( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=390

/**
 * Cast a flat object into the specified flat type.
 * @param obj
 * @param type
 * @return raw
 */
raw rawType( void obj,  void type) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=433

/**
 * Creates a NULL list.
 * @return null
 */
null Null() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=488

/**
 * Creates a cpx vector
 * \a re and \a im must be of type DOUBLE or LONG, both scalars or same size
 * @param re *long*  real part
 * @param im *long*  imaginary part
 * @return z *cpx*
 */
z cpx( void re,  void im) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=501

/**
 * Creates a varspc with given fields
 * @code
 * varspc('name','Doe','firstname','John','age','66');
 * @endcode
 *
 * @param field_n field name
 * @param val_n field value
 * @return varspc
 */
varspc varspc( void field_n,  void val_n) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=629

/**
 * Creates a varspc from a struc
 * @param obj
 * @return varspc
 */
varspc struct2varspc( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=666

/**
 * Creates a list of name.
 * A name is a string of maximum 31 chars.
 * @param name0 *str*
 * @param ...   (str)
 * @return res  (strn)
 */
res strn( void name0,  void ...) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=681

/**
 * Creates a list of \a long or \a double from \a to \b with given \a step
 * If one of argument si s a \a double, result will be a \a double.
 * @code
 * lin(4,8) => [ 4 5 6 7 8 ]
 * lin(4,2,8) => [ 4 6 8 ]
 * @endcode
 *
 * @param a start value
 * @param step optional
 * @param b end value
 */
lin( void a,  void step,  void b) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=730

/**
 * Creates a list of 1.
 * - if n is type long creates a list of n long equal to 1.
 * - if n is type double creates a list of n double equal to 1.
 * @param n
 * @return lst
 */
lst ones( void n) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=867

/**
 * Are two objects identical?
 * @param obj1
 * @param obj2
 * @return \c 1 if identical
 */
UNK same( void obj1,  void obj2) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=913

/**
 * Is an object empty?
 * @return \c 1 if obj is NULL or its size is zero
 */
UNK isempty() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=928

/**
 * Is an object NULL?
 * @return b \c 1 if obj is NULL
 */
b isnull() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=943

/**
 * Is an object scalar?
 * @param obj
 * @return b \c 1 if obj' size is 1
 */
b isScalar( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=956

/**
 * Is an object not scalar?
 * @param obj
 * @return b \c 1 if obj' size is not 1
 */
b isNotScalar( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=971

/**
 * Return the number of element in obj
 * @param obj
 * @return long
 */
long size( void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=986

/**
 * Return the reverse list
 * @param lst *list* to reverse
 *
 * @code
 * flip([1,2,3]) -> [3,2,1]
 * @endcode
 */
flip( void lst) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1014

/**
 * Print an object on the console
 * @param format (optional) format string
 * @param obj
 *
 * @code
 * disp('%02d',4) => '04'
 * @endcode
 */
disp( void format,  void obj) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1033

/**
 */
dump() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1085

/**
 * Set an object (sub) field.
 * do the same job as obj.f1[0].f2[0].fn(0)=val (where [] is {} or () as appropiate)
 *
 * @param obj should be a SCALAR c-struct list. sub obj fhould be sub c-struct
 * or scalar obj c-struct
 * @param fieldname
 * @param val
 *
 * @code
 * obj = setField(obj,'f1.f2.fn',val);
 * @endcode
 */
setField( void obj,  void fieldname,  void val) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1163

/**
 * Get an object (sub) field.
 * do the same job has obj.f1[0].f2[0].fn(0) (where [] is {} or () as appropriate)
 * obj should be a SCALAR c-struct list
 * @param obj should be a SCALAR c-struct list. sub obj fhould be sub c-struct
 * or scalar obj c-struct
 * @param fieldname
 * @return field value
 */
field getField( void obj,  void fieldname) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1236

/**
 * Fast ascending short on a LONG list
 * @param obj
 * @param field (optional) field to consider for the sort
 * @return sorted *list*
 */
sorted sort( void obj,  void field) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1279

/**
 * Fast ascending sort on a obj list.
 * @param lst  (lst)
 * @param field *L.name*   (optional) field to consider for the sort
 * @return ind  (L.long)
 */
ind isort( void lst,  void field) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1360

/**
 * Is object field equal to given value?
 * @param obj (user type with fields) any length.
 * @param field (str or scalar name) field in obj to test.
 * @param valRef (str or scalar long double name)
 * @return bool *long*  bool is a list of 0 or 1.
 */
bool objFieldEqual( void obj,  void field,  void valRef) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1422

/**
 * Find the first element in a list equal to something.
 * @param obj any length.
 * @param value (any)
 * @return index *long*  -1 if no match found.
 */
index findFirstElt( void obj,  void value) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1439

/**
 * Find the last element in a list equal to something.
 * @param obj any length.
 * @param value (any)
 * @return index *long*  -1 if no match found.
 */
index findLastElt( void obj,  void value) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1472

/**
 * Find all the elements in a list equal to something.
 * @param obj any length.
 * @param value (any)
 * @return index (lst_long)
 */
index findElt( void obj,  void value) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1505

/**
 * Find all the elements in a list whose given field is equal to something.
 * @param obj any length.
 * @param field name of field
 * @param value (any)
 * @return index (lst_long)
 */
index findFieldElt( void obj,  void field,  void value) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1539

/**
 * Is there element different than zero in given list?
 * @param list of long or double
 * @return b \c 1 if there is at least one non zero element
 *
 * @code
 *  any([0,1,1,0]) => 1
 *  any([]) => 0
 * @endcode
 */
b any( void list) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1558

/**
 * Is there no zero element in given list?
 * @param list of long or double
 * @return b \c 1 if there is no zero element
 *
 * @code
 *  every([0,1,1,0]) => 0
 *  every([]) => 1
 * @endcode
 */
b every( void list) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1605

/**
 * Return the indexes of the non zero elements
 * Implemented on LONG and DOUBLE.
 * @param lst
 * @return idxs *L.long*
 *
 * @code
 * find([0,1,1,0]) => [1,2]
 * @endcode
 * @todo A REFAIRE AVEC APPEL objFind
 */
idxs find( void lst) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1652

/**
 * Return first non zero element.
 * implemented on LONG and DOUBLE.
 * @param lst *list*
 * @return elt or -1 if all zero
 */
elt first( void lst) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1705

/**
 * Return last non zero element.
 * implemented on LONG and DOUBLE
 * @param lst
 * @return b \c -1 if all zero
 */
b last( void lst) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1754

/**
 * Creates a list of uniques random indexes from 0 to n-1
 * @param n *long*
 * @return ind *L.long*
 */
ind idxRandIndex( void n) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1801

/**
 * Fast ascending short on a LONG list and delete duplicated element.
 * The result is always sorted.
 * @param lst
 * @return sorted unique list
 */
sorted unique( void lst) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1814

/**
 * Return the intersection of two set.
 * Implemented on LONG. The result is short and unique.
 *
 * @param lst1
 * @param lst2
 * @return lst intersection of given lists
 *
 * @code
 *  setInter([3,1,2,2],[4,3,2,2]) => [2,3]
 * @endcode
 */
lst setInter( void lst1,  void lst2) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1831

/**
 * Return the union of two set.
 * Implemented on LONG. The result is short and unique.
 *
 * @param lst1
 * @param lst2
 * @return lst union of given lists
 *
 * @code
 *  setUnion([3,1,2,2],[4,3,2,2]) => [1,2,3,4]
 * @endcode
 */
lst setUnion( void lst1,  void lst2) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1901

/**
 * Return the element in idx1 and not in idx2
 * implemented on LONG, the result is short and unique.
 * @code
 *  setDiff([3,1,1,2,2],[4,3,2,2]) => 1
 * @endcode

 * @param idx1 *[long]*
 * @param idx2 *[long]*
 * @return idx *[long]*
 */
idx setDiff( void idx1,  void idx2) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=1940

/**
 * @todo doc
 * Find list of elementary loops.
 * on suppose que chaque element du set designe un autre element du set (val>=0), ou n'intervient pas (val<0 || val>=size(set))
 * @param set
 * @return r
 */
r setFindLoop( void set) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2007

/**
 * Remove an element from a list.
 * Same as idx.(find(lst==val)) = [];
 * @param lst
 * @param val
 * @return list without deleted element
 */
list dropElt( void lst,  void val) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2082

/**
 * Increment a list of multiple indexes.
 * @param index
 * @param nmax
 * @return index
 * @return done
 */
index done idxIncMultiIndex( void index,  void nmax) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2101

/**
 * Add an element to a list.
 * Implemented on long or double.
 * @param idx a long or double
 * @return lst
 * @code
 * idxsAddElt([4,6,5],6) => [4,6,6,5]
 * @endcode
 */
lst idxsAddElt( void idx) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2121

/**
 * @todo doc
 */
idxsAddEltNew() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2145

/**
 * Is \a idx member of given list?
 * @param idx
 * @param lst
 * @return b \c 1 if idx is a member of lst
 */
b idxsIsElt( void idx,  void lst) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2163

/**
 * @todo doc To Be Written.
 */
idxsIsOk() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2180

/**
 * @todo doc To Be Written.
 * @param ? *long*
 * @return b *long*
 */
b idxsIsOkStrict( void UNK) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2192

/**
 * Returns elements of first list that are not present in second list.
 * @param lst1
 * @param lst2
 * @return lst
 * @code
 * idxsSetDiff([1,3,4],[2,3,5]) =>  [ 1 4 ]
 * @endcode
 */
lst idxsSetDiff( void lst1,  void lst2) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2205

/**
 * Most significant Unsigned Bytes to long;
 * most significant byte is first (hc12)
 * @param str a string containing one to four bytes
 * @return long
 */
long uMsb2long( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2235

/**
 * Most significant Signed Bytes to long;
 *  most significant byte is first (hc12)
 * @param str is a string containing one to four bytes;
 * @return long
 */
long sMsb2long( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2262

/**
 * Convert Long to Most significant Unsigned Bytes;
 * most significant byte is first (hc12)
 * @param str is a string containing n bytes;
 * @return r *str*
 */
r long2uMsb( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2293

/**
 * Convert long 2 Most significant Signed Bytes.
 * Most significant byte is first (hc12, arm).
 * @param str is a string containing n bytes;
 * @param x *long*
 * @param n *long*  if n is omitted, n=2
 * @return str *L.char*
 */
str long2sMsb( void str,  void x,  void n) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2316

/**
 * xor checksum on char.
 * @param str *L.char*
 * @return val (char)
 */
val xorChecksum( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2341

/**
 * Cast double to float
 * @param double
 * @return float
 */
float double2float( void double) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2376

/**
 * Cast float to double
 * implemented on LONG only
 * @param long
 * @return double
 */
double float2double( void long) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2413

/**
 * translate a gray number to a binary number.
 * @param long
 * @return r *long*
 */
r gray2bin( void long) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2451

/**
 * translate a binary number to a gray number
 * @param long
 * @return r *long*
 */
r bin2gray( void long) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2485

/**
 * @}
 * @addtogroup rlab_string
 * @{
 */
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2509

/**
 * Print a number into a new string.
 * Implemented on scalar long double and complex number
 * @see vnum2str for list of numbers
 * @param num number to convert
 * @return str
 */
str num2str( void num) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2516

/**
 * Print a list of number in a string with [ ].
 * Implemented on L.long L.double and L.cpx number.
 * @see num2str() for scalar number
 * @param vnum a list of number
 * @return str
 */
str vnum2str( void vnum) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2561

/**
 * Evaluate an expression and convert to SCALAR numeric type.
 *
 * @param expr containing a number or a mathematic formula, eg '1' '1.' '1*1' 'pi' 'sin(pi)'  etc...
 * @return or *list* of numbers or (Null) if an error occur or if the result is not scalar numeric.
 * @see constEval() and eval()
 * @return val the number
 */
or val str2num( void expr) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2621

/**
 * Evaluate an expression and convert to list of numbers
 *
 * @param expr containing a number list eg '[4,5,6]'
 * @return a *list* of numbers or (Null) if an error occured
 */
a str2vnum( void expr) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2649

/**
 * Evaluate string as a command line script
 * @return the local variable defined during evaluation in a varspc
 * @see str2num(), eval()
 * @param str
 * @return varspc
 */
the varspc eval( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2675

/**
 * Evaluate string representing a constant.
 * The string should not call runtime depend function.
 * @param str may be '1' '1.' '1*1' 'pi' 'sin(pi)' '[1,1]' , '"tom"' etc...
 * @return val
 */
val constEval( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2696

/**
 * Format a string.
 * @param fmt %g %f %s  (%-8.8g) (%-8.8f) or str(%-20s)
 * @param arg scalar numeric (LONG DOUBLE COMPLEX) or string
 * @return str
 */
str sprintf( void fmt,  void arg) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2711

/**
 * Format a string and display it on the console.
 * @param fmt %g %f %s  (%-8.8g) (%-8.8f) or str(%-20s)
 * @param arg scalar numeric (LONG DOUBLE COMPLEX) or string
 */
printf( void fmt,  void arg) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2735

/**
 * Format a string and display it colored on the console.
 * @param color one of 'BLACK', 'BLUE', 'GREEN', 'CYAN', 'RED', 'MAGENTA',
 * 'BROWN', 'LIGHTGRAY', 'DARKGRAY', 'LIGHTBLUE', 'LIGHTGREEN', 'LIGHTCYAN',
 * 'LIGHTRED', 'LIGHTMAGENTA', 'YELLOW', 'WHITE', 'DEFAULT'
 * @param fmt %g %f %s  (%-8.8g) (%-8.8f) or str(%-20s)
 * @param arg scalar numeric (LONG DOUBLE COMPLEX) or string
 */
printcf( void color,  void fmt,  void arg) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2762

/**
 * Case sensitive find of a key string into a data string.
 * @param data *string*
 * @param key *string*
 * @return multiple occurences indexes
 *
 * @code
 * strfind('rantanplan','an') =>  [ 1 4 8 ]
 * @endcode
 */
multiple strfind( void data,  void key) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2792

/**
 * Case sensitive compare of two strings.
 * @param s1 *L.char*
 * @param s2 *L.char*
 * @return b 0 if equal, 1 or -1 otherwise
 */
b strcmp( void s1,  void s2) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2828

/**
 * Case sensitive compare of nth first char of two strings.
 * @param s1 *L.char*
 * @param s2 *L.char*
 * @param n number of chars to compare
 * @return b 0 if equal, 1 or -1 otherwise
 */
b strncmp( void s1,  void s2,  void n) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2844

/**
 * Is \a key string present in \a ref string? (case insensitive sarch).
 * @param ref *string*
 * @param key *string*
 *
 * @return b 1 if match occurs or 0
 * @code
 * strMatch('foobar','ba') => 1
 * @endcode
 */
b strMatch( void ref,  void key) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2860

/**
 * Lower the case.
 * @param string
 * @param string in lower case
 */
tolower( void string,  void string) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2879

/**
 * Upper the case.
 * @param string
 * @param string in upper case
 */
toupper( void string,  void string) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2903

/**
 * Creates a string with n spaces.
 * @param n *long*
 * @return str *L.char*
 */
str spc( void n) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2927

/**
 * Read a long into a string.
 * No evaluation is done.
 *
 * @code
 * strReadLong('1') => 1
 * strReadLong('1+1') => makes an error
 * @endcode
 *
 * @param long
 * @param string
 */
strReadLong( void long,  void string) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=2981

/**
 * Read a double into a string.
 * No evaluation is done.
 *
 * @code
 * $strReadDouble('1') => 1.0
 * $strReadDouble('1+1') => makes an error
 * @endcode
 *
 * @param double
 * @param string
 */
strReadDouble( void double,  void string) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3041

/**
    Read one cpx into a string.
    No evaluation is done.

    @code
    strReadCpx('cpx(1,2)') => cpx(1.0,2.0)
    strReadCpx('[cpx(1,2)]') => makes an error
    @endcode

    @param string
    @return cpx
 */
cpx strReadCpx( void string) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3129

/**
 * Is a string blank?
 * @param str
 * @return b \c 1 if str is null,empty or contain only tab space and newline
 */
b strIsBlank( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3152

/**
    Replaces in the string \a data all the occurrences of the source string \a key with
    the destination string \a newkey. The parameters old and new may be of any length,
    and their lengths are allowed to differ.
    @code
    strReplace('foobar','oo','00') => 'f00bar'
    @endcode

    @param data
    @param key
    @param newkey
    @return str
 */
str strReplace( void data,  void key,  void newkey) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3211

/**
 * Repalce a char '\' by two char'\\' in a string.
 * @param st a string containing text.
 * @return st a string containing text.
 */
st strDoubleBackslash( void st) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3276

/**
 * Ascii to Hex conversion
 * @param str
 * @return str hexadecimal representation (size is doubled)
 */
str str2hex( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3291

/**
 * Hex to Ascii conversion
 * @see str2hex
 * @param str_hex *string* with chars in the set [0123456789abcdefABCDEF]
 * @return str which is corresponding representation. If string size is odd then
 * a 0 is appended.
 */
str hex2str( void str_hex) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3324

/**
 * ASCII to binary.
 * - '1' bits replaced by their index
 * - '0' bits replaced by '_'
 *
 * Example with 'a' (01100001 in binary).
 * @code
 * sprintBit('a') => '_65____0'
 * @endcode
 * @param str
 * @return binary representation
 */
binary sprintBit( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3402

/**
 * @}
 * @addtogroup rlab_services
 * @{
 */
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3452

/**
 * Get number of arguments passed to current function.
 * @return long number of arguments
 */
long nargin() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3458

/**
 * Get number of arguments to assign when returning of current function.
 * @return long number of arguments
 */
long nargout() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3495

/**
 * Get the runtime id (tid) of the script.
 * if the script is running in a local runtime (callback) return 0.
 * @return tid
 */
tid me() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3532

/**
 * Stop the script execution for duration defined by t.
 * @param t time unit : osClk.
 * @return
 */
UNK wait( void t) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3546

/**
 * Give the elapsed delay between now and the time the script should have start running afer a wait.
 * Time unit : osClk.
 * @return longdelay
 */
longdelay wakeUpDelay() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3571

/**
 * Display the name of the curent local variables.
 */
who() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3587

/**
 * @internal
 * Compile and (re)link some scripts.
 * Compile from text files
 * @param name1 text filename
 * @param name2 text filename
 * @param ...
 */
compile( void name1,  void name2,  void ...) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3604

/**
 * @internal
 * Remove the scripts who defines the given function/
 * @param fnc1 a name of a function.
 * @param fnc2 a name of a function.
 * @param ...
 */
unlink( void fnc1,  void fnc2,  void ...) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3645

/**
  true if the guiven string is the name of a callable function.
  @param fncName *L.char*  a string naming a function.
  @return bool *long*  0 or 1.
 */
bool isFunc( void fncName) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3682

/**
  Return the maximum number if input and output arguments of a function
  @param funcName *L.char*  a string naming a function.
  @return nIn *long* function nargin (-1 if func not defined)
  @return nOut *long* function nargout (-1 if func not defined)
 */
nIn nOut getFuncNarg( void funcName) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3700

/**
 * Call a function by name.
 * The stack of the caller is used.
 * @param fnc the name of the function to call (script or c)
 * @param args a list of argument to pass.
 * @return out *L.void*  values returned by called function
 */
out call( void fnc,  void args) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3731

/**
 * Call a function by name.
 * The stack of the caller is used.
 * @param fnc the name of the function to call (script or c)
 * @param arg1 first argument
 * @param ...
 * @param argN last argument
 * @return out *L.void*  values returned by called function
 */
out acall( void fnc,  void arg1,  void ...,  void argN) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3844

/**
 * Executes a script in a different thread.
 *
 * @code
 * tid = exe('funcname',{ param1, param2,...}, nargout);
 * @endcode
 *
 * @param function name
 * @param function arguments
 * @param nargout
 * @return r ?
 */
r exe( void function,  void function,  void nargout) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3934

/**
 * @todo doc
 * rtmGroupJoin('groupName',tid)
 */
rtmGroupJoin() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=3984

/**
* Set priority
 * @todo doc
 * @param groupName *L.char*
 * @param prio *long*
 */
rtmGroupSetPrio( void groupName,  void prio) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4011

/**
 * Execute a command line in a different thread.
 * @param command_line *L.char*
 * @return tid
 */
tid exeCmd( void command_line) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4027

/**
 * Kill a script.
 * @param tid thread runtime id
 */
killscp( void tid) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4042

/**
 * Return the state of the script.
 * State is one of the following integers:
 *  - kScpUnInited = 0,
 *  - kScpRun = 1,
 *  - kScpWait = 2,
 *  - kScpCmdDone = 3,
 *  - kScpLocked = 4,
 *  - kScpDone = -1,
 *  - kScpError = -2,
 *
 * @return long state
 */
long getScpState() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4063

/**
 * Return the result of the script in a cell.
 * @param tid
 * @return result or Null if scp tid is not done
 */
result getScpRes( void tid) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4091

/**
 * Print a warning on stdout.
 * @param msg
 */
warning( void msg) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4112

/**
 * Generate an error.
 * When call, it will immediatly exit successively all block and calling
 * functions until the first try block is encounterd.
 * - if a try block is reached, the execution will go on. The next statement to
 *   be executed will be first statement of the associated catch block.
 *   No error message is displayed. The message can be read with lastError(),
 *   until a new error occurs.
 * - if no try block is reached the runtime in wich the error occurs is stopped.
 *   The error message is displayed in red on the stdio. The runtime remain
 *   present untils it's freeed by someone.
 *
 * @param msg a string containing a clear short text message explaining the
 * reason why it is necessary to stop execution.
 *
 */
error( void msg) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4142

/**
 * Generate a fatal error (exit application).
 * @param msg a string containing a clear short text message explaining the
 * reason why it is nessary to stop execution. If not passed redo the last error.
 */
fatalError( void msg) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4182

/**
 * Return the message of the last error, including the calling trace.
 * @return msg the string of last error message.
 */
msg lastError() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4216

/**
 * Return the message of the last error, without the calling trace.
 * @return msg the string of last error message.
 */
msg lastShortError() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4229

/**
 * Create a cbk
 *
 * @param  proto    (L.Char) proro of the cbk to create
 * @code
    //proto is one of:
    proto = "[out0:type,out1:type] = cbkName(in0,in1,in2)"
    proto = "[out0:type,out1] = cbkName(in0,in1,in2)"
    proto = "[out0] = cbkName(in0,in1,in2:type)"
    proto = "cbkName()"
    proto = "cbkName"
 * @endcode
 * @return cbk_proto
*/
cbk_proto cbkNew( void proto) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4243

/**
 * Set a created cbk
 *
 * @param  cbk_proto   cbk to set
 * @param  function name (L.char) name of the function to link to the cbk
 */
cbkSet( void cbk_proto,  void function) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4274

/**
* Call a declared cbk
* cbkCall(cbk,{args});
*
* @code
   // create cbk
   c = cbkNew("[res1,res2] = myCbk(a,b)");

   //set cbk
   cbkSet(c,"myFunc");

   //call cbk
   out = cbkCall(c,{a,b});
   with: res1=out.{0}; res2=out.{1};
* @endcode
*
* @param  cbk_proto cbk to call
* @param  arguments
* @return out args from the cbk
*/
out cbkCall( void cbk_proto,  void arguments) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4290

/**
* Get ref from str
* @param  str
* @return ref
*/
ref getRef( void str) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\script\scpfunc.c li=4319

//Kiwi auto close bracket!
/**
 * @}
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\script\scpfunc.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\script\script.c
// END of C:\206-3_11\devLibRlab\src\script\script.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\clog.c
/**
   @addtogroup rlab_logging Logging (console)
   Log messages to console or/and file based on threshold levels.
   @{
*/
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=18

/**
   Logs a message with level DEBUG.
   @param msg *L.char* the message format string
   @param args *L.char* the arguments which are merged into msg using the string formatting operator.

   logDebug("Error %d", 42);
*/
logDebug( void msg,  void args) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=902

/**
   Logs a message with level INFO.
   @param msg *L.char* the message format string
   @param args *L.char* the arguments which are merged into msg using the string formatting operator.

   logInfo("Error %d", 42);
*/
logInfo( void msg,  void args) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=916

/**
   Logs a message with level WARN.
   @param msg *L.char* the message format string
   @param args *L.char* the arguments which are merged into msg using the string formatting operator.

   logWarn("Error %d", 42);
*/
logWarn( void msg,  void args) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=930

/**
   Logs a message with level ERROR.
   @param msg *L.char* the message format string
   @param args *L.char* the arguments which are merged into msg using the string formatting operator.

   logError("Error %d", 42);
*/
logError( void msg,  void args) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=944

/**
   Logs a message with level INSTALL.
   @param msg *L.char* the message format string
   @param args *L.char* the arguments which are merged into msg using the string formatting operator.

   logInstall("Error %d", 42);
*/
logInstall( void msg,  void args) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=958

/**
   Set console logging level
   @param level minimum level above which logging is enabled
   - 0: DEBUG
   - 1: INSTALL
   - 2: INFO
   - 3: WARN
   - 4: ERROR
   - 5: NONE
*/
logConsoleLevel( void level) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=972

/**
   Add a word to the console white list logging filter
   (only the messages containing this a word of the white list will be displayed)
   @param filter word
*/
logConsoleAddWhiteList( void filter) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=990

/**
   Add a word to the console black list logging filter
   (only the messages containing this a word of the white list will be displayed)
   @param filter word
*/
logConsoleAddBlackList( void filter) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\clog.c li=1003

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\sys\clog.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\compLog.c
/**
    @addtogroup rlab_logreplay Logging (replay)
    Cyclic log buffering (zip compressed)
    @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=1

/**
 * Init zip log.
 * @param szZipBuff
 * @param szBloc
 * @param quality -1..10
 */
cl_init( void szZipBuff,  void szBloc,  void quality) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2391

/**
 * Log an element into the main log. Clid should be an official value.
 * @param clid
 * @param flat_obj
 */
cl_log( void clid,  void flat_obj) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2408

/**
 * Log an element into the mainCst log. Clid should be an official value.
 * @param clid
 * @param flat_obj
 */
cl_logPref( void clid,  void flat_obj) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2431

/**
 * Clear zip log (free mem).
 */
cl_clear() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2456

/**
 * Raz zip log (empty content, ready for fresh new data).
 */
cl_raz() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2468

/**
 * Save the current log into a file.
 * @param fname
 * @param maxDuration ms (long)
 */
cl_save( void fname,  void maxDuration) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2480

/**
 * Disp Info.
 */
cl_info() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2581

/**
 * Disp Info.
 */
cl_infoGetPct() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2617

/**
 * Request Info.
 */
cl_getLockedSizeRawBuff() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2633

/**
 * Request Info.
 */
cl_isSaving() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2646

/**
 * Load a log from a file for replay.
 * @param fname
 * @retval err
 * @retval clk_start
 * @retval clk_end
 */
err clk_start clk_end clr_load( void fname) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2659

/**
 * Close a log from a file for replay.
 */
clr_close() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2680

/**
 * Get next clid for replay.
 * @return err
 */
err clr_getNextClid() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2692

/**
 * Get next clid for replay.
 * @param rawData_typed
 * @return err
 * @return clid
 * @return tclock
 */
err clid tclock clr_read( void rawData_typed) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2705

/**
 * Get cl_offset for next read.
 * @return cl_offset
 */
cl_offset clr_tell() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2762

/**
 * Get cur read position in log in pourcent.
 * @return double
 */
double clr_tellPct() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2778

/**
 * Set next clid to read.
 * @pararm cl_offset
 */
clr_seek() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2792

/**
 * list all log currently open
 * @pararm cl_offset
 */
clr_opened() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2808

/**
 *  Get last error definition in str

    empty if no error
 * @return *str* last error
 */
UNK cl_getLastError() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\compLog.c li=2901

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\sys\compLog.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\consBuff.c
// END of C:\206-3_11\devLibRlab\src\sys\consBuff.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\crypt.c
/**
 * @file crypt.c
 * @brief This file contains encrypt/decrypt functions
 * @date 15/04/2015
 * @author oussama.elhamzaoui@balyo.com
 */
//level=0 fn=C:\206-3_11\devLibRlab\src\sys\crypt.c li=1

// END of C:\206-3_11\devLibRlab\src\sys\crypt.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\datefile.c
// END of C:\206-3_11\devLibRlab\src\sys\datefile.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\error.c
// END of C:\206-3_11\devLibRlab\src\sys\error.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\etype.c
/**
 * @addtogroup rlab_builtin_types
 * @{
*/
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\etype.c li=11

/**
 * To Be Written.
 * @param ?
 * @return ?
 */
UNK etype( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\etype.c li=1057

/**
 * Convert etype to obj
 * @param etype
 * @param type *L.char* (optional)
 * @return obj
 */
obj etype2obj( void etype,  void type) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\etype.c li=1070

/**
 * To Be Written.
 * @param ?
 * @return ? *long*
 */
UNK etypeScan( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\etype.c li=1093

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\sys\etype.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\filter.c
/**
 * @addtogroup rlab_math
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\filter.c li=9

/**
 * To Be Written.
 * @param b
 * @param a
 * @return filterObject
 */
filterObject filterNew( void b,  void a) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\filter.c li=143

/**
 * To Be Written.
 * @param filt
 * @param x
 * @return y
 */
y filter( void filt,  void x) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\filter.c li=161

/**
 * To Be Written.
 * @param filt
 */
filterRaz( void filt) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\filter.c li=183

/**
 * To Be Written.
 * @param m
 * @param ?
 * @return ?
 */
UNK linAdj( void m,  void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\filter.c li=216

/**
 * Create a linAdjRec record from 4 doubles
 * Simplify the syntax in preferences file
 * @code
  rec = linAdjRec(m0,v0,m1,v1);
  rec = linAdjRec([m0,v0],[m1,v1]);
  rec = linAdjRec([m0,v0,m1,v1]);
 * @endcode
 * @param mo
 * @param v0
 * @param m1
 * @param v1
 * @return long
 */
long linAdjRec( void mo,  void v0,  void m1,  void v1) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\filter.c li=236

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\sys\filter.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\help.c
/**
 * @addtogroup rlab_help
 * @{
 */
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=11

/**
 * Create an empty help environement.
 * @retval hlp *L.helpEnv*
 */
hlp help_NewEnv() {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=93

/**
 * Write new text line in the given help \a hlp.
 * @param hlp *L.helpEnv*
 * @param txt *string* to write
 * @param from *long* the first reference line index
 * @param to   long the last  reference line index
 */
help_WriteLine( void hlp,  void txt,  void from,  void to) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=111

/**
 * Set current file reference for next write in the given help \a hlp.
 * @param hlp *L.helpEnv*
 * @param filename a string
 */
help_WriteFile( void hlp,  void filename) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=167

/**
 * Add help \a hlpNew to the given help \a hlp.
 * @param hlp    L.helpEnv
 * @param hlpNew *L.helpEnv*
 */
help_Conc( void hlp,  void hlpNew) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=183

/**
 * Print an error message on the console.
 * @param hlp *L.helpEnv*
 * @param line *long* the line number where occurs the error.
 * @param fmt a string as in printf
 * @param ...
 */
help_Error( void hlp,  void line,  void fmt,  void ...) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=269

/**
 * Print a warning message on the console.
 * @param hlp *L.helpEnv*
 * @param line *long* the line number where occurs the error.
 * @param fmt a string as in printf
 * @param ...
 */
help_Warning( void hlp,  void line,  void fmt,  void ...) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=305

/**
 * Convert doxygen line to real file/line number.
 * @param hlp *L.helpEnv*
 * @param line *long* the line number where occurs the error.
 */
help_GetRef( void hlp,  void line) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=341

/**
 * To Be Written.
 * @param st *L.char*
 * @return r *L.char*
 */
r htmlConvertTxt( void st) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=417

/**
 * Format indent space and add it to the string.
 * Copy the character in \a st2 at the end of \a st1 with the following rules:
 * - Whenever a '\n' is encounter in st2 write a '\n' in \a st1 if it's not alreday
 * starting with a new line. Avoid writing empty line in \a st1.
 * - When copying other char, append n times the identChar if it's at beginning of
 * a line in \a st1
 * @param st1
 * @param st2 with '\n'
 * @param n the long number or space to add before writng a line
 * @param identChar the charracter to pad.
 * @return st1
 */
st1 strIdentAndConcTxt( void st1,  void st2,  void n,  void identChar) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=433

/**
  Remove starting and ending space in a string.
  The following char are consider as space ' ' '\\t' '\\n'
  @param st a string
  @return st a string
 */
st strStrip( void st) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\help.c li=512

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\sys\help.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\i18n.c
// END of C:\206-3_11\devLibRlab\src\sys\i18n.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\idadr.c
// END of C:\206-3_11\devLibRlab\src\sys\idadr.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\loopBuff.c
// END of C:\206-3_11\devLibRlab\src\sys\loopBuff.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\md5.c
// END of C:\206-3_11\devLibRlab\src\sys\md5.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\serDesc.c
// END of C:\206-3_11\devLibRlab\src\sys\serDesc.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\tcpip.c
/**
 * @addtogroup Protocols
 * @{
 * @addtogroup tcpip TCP/IP sockets-based commands
 * Sockets constitute a mechanism for delivering incoming data packets to the
 * appropriate application process or thread, based on a combination of local
 * and remote IP addresses and port numbers.
 * @{
 */
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=1

/**
 * Open a socket to receive udp datagram on a specific port.
 * @param port
 * @return idudp
 */
idudp udpRxOpen( void port) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=428

/**
 * Receive pending data, don't wait if nothing to receive.
 * @param idudp
 * @return data
 * @return ip
 */
data ip udpRxRcvOne( void idudp) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=442

/**
 * Close a socket opened by udpRx0pen().
 * @param idudp
 */
udpRxClose( void idudp) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=480

/**
 * Open a socket to send udp datagram on a specific port to a specific ip.
 * @param ip
 * @param port
 * @return idudp
 */
idudp udpTxOpen( void ip,  void port) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=496

/**
 * Retrieve the ip program for this socket.
 * @param idudp
 * @return ip
 */
ip udpTxGetIP( void idudp) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=513

/**
 * Send data over the network.
 * @param idudp
 * @param data
 */
udpTxSndOne( void idudp,  void data) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=532

/**
 * Close a socket opened by udpTx0pen().
 * @param idudp
 */
udpTxClose( void idudp) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=552

/**
 * Connect to a server.
 * @param ip
 * @param port
 * @return idtcp
 */
idtcp tcpConnect( void ip,  void port) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=569

/**
 * Check if the connection is established.
 * @param idtcp
 * @return inProgress
 */
inProgress tcpIsConnectInProgress( void idtcp) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=593

/**
 * Start to listen on a port for new client.
 * @param port
 * @return idtcpServ
 */
idtcpServ tcpListen( void port) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=614

/**
 * New tcp connection from a new client.
 * Return immediately with idtcpServ=0 and ip=NULL if no new client available.
 * @param idtcpServ
 * @retval idtcp
 * @retval ip
 */
idtcp ip tcpAccept( void idtcpServ) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=635

/**
 * Send data over the network.
 * To Be Written.
 * @param idtcp
 * @param data
 */
tcpSnd( void idtcp,  void data) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=661

/**
 * Receive pending data, don't wait if nothing to receive.
 * @param idtcp
 * @return data
 */
data tcpRcv( void idtcp) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=689

/**
* Receive pending data in hex, don't wait if nothing to receive.
* @param idtcp
* @return data
*/
data tcpRcvInHex( void idtcp) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=709

/**
 * Close a connection obtained by tcpConnect() / tcpAccept() / tcpListen().
 * @param idtcp
 */
tcpClose( void idtcp) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=735

/**
 * Convert ipv4 str adress to long.
 * @param ipv4
 * @return ipint
 */
ipint ipStr2num( void ipv4) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=748

/**
 * Convert ip integer to a string.
 * @param ipint
 * @return ipv4Str
 */
ipv4Str ipNum2str( void ipint) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=763

/**
 * Convert an ip string 'x.x.x.x:port' to 'x.x.x.x' port
 * @param tcpipStr
 * @return ipStr
 * @return port
 */
ipStr port tcpipCleanAdr( void tcpipStr) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=780

/**
 * List all tcpip socket currently opened.
 */
tcpInfo() {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=813

/**
 * Retrieves host ip corresponding to a host name from a host database
 * @param hostname
 * @return ip
 */
ip getHostByName( void hostname) {}
//level=2 fn=C:\206-3_11\devLibRlab\src\sys\tcpip.c li=829

//Kiwi auto close bracket!
/**
 * @}
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\sys\tcpip.c
//-------------------------------------------------
// start of C:\206-3_11\devLibRlab\src\sys\txtParser.c
/**
 * @addtogroup rlab_parsing
 * @{
*/
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=9

/**
 * Load a text code source, for parsing.
 * @param file_name a string naming the file to read.
 * @return txtParserFile a struct containing the text of the file and aditional statistic.
 */
txtParserFile txtParser_LoadFile( void file_name) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=886

/**
 * Skip space character including CR.
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipSpcCr( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=951

/**
 * Skip space character excluding CR (stop at end of line).
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipSpc( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=968

/**
 * Skip the body of a struct or function.
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipBody( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=985

/**
 * Skip a charater.
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipChar( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1001

/**
 * Skip a C comment ( /\* ).
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipCComment( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1017

/**
 * Skip a C comment (//).
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipCppComment( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1035

/**
 * Return to the start of the current line.
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_ReturnToSOL( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1053

/**
 * Skip to the end of the current line.
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipToEOL( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1069

/**
 * Skip to the end of the current line.
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipName( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1086

/**
 * Skip a string.
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position, after skiping the string.
 */
ptr txtParser_SkipString( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1105

/**
 * Retrieve a scpCFunc (ie static long txtParser_SkipStringFnc(rtm r) { ).
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  txtParser_ScpCFunc a structure containing info.
 */
txtParser_ScpCFunc txtParser_IsScpCFunc( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1123

/**
 * Retrieve a scpFunc (ie export function [a,b,c] = name(a,b,c) { ).
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  txtParser_ScpFunc a structure containing info.
 */
txtParser_ScpFunc txtParser_IsScpFunc( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1140

/**
 * Retrieve a scpCDecl (ie static cfunc = {...} ).
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  txtParser_ScpCDecl a structure containing info.
 */
txtParser_ScpCDecl txtParser_IsScpCDecl( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1156

/**
 * Print a warning message.
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the position of the error.
 * @param   fmt a format string as in printf.
 * @param   ... aditional argument depending on fmt.
 */
txtParser_Warning( void txtParserFile,  void ptr,  void fmt,  void ...) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1173

/**
 * Print an error message.
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the position of the error.
 * @param   fmt a format string as in printf.
 * @param   ... aditional argument depending on fmt.
 */
txtParser_Error( void txtParserFile,  void ptr,  void fmt,  void ...) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1209

/**
 * Identify what the cuuernt position
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the position of the error.
 * @return type a string
 * type could be on of
 * - "EOF"
 * - "spc"
 * - "CCom"
 * - "CppCom"
 * - "docCCom"
 * - "docCppCom"
 * - "body"
 * - "name"
 * - "string"
 * - "other"
 */
type txtParser_Identify( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1246

/**
 * Extract a portion of the file.
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   pts a long containing the position of the first char
 * @param   pte a long containing the position of the next char of the last char.
 * @retval txt a string
 * @retval lineFrom a long
 * @retval lineTo   a long
 */
txt lineFrom lineTo txtParser_Extract( void txtParserFile,  void pts,  void pte) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1314

/**
 * Get the next doc tag.
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current pos.
 * @param   pte a long containing the position of the next char of the last char to examine.
 * @retval ptr pointing on next line
 * @retval tag a string (one word or empty if pte reached)
 * @retval opt1 a string (one word or empty)
 * @retval opt  a string (some word) (end of line content)
 */
ptr tag opt1 opt txtParser_GetNextDocTag( void txtParserFile,  void ptr,  void pte) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1349

/**
 * Extract a portion of the file.
 * @param   txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   pts a long containing the position of the first char
 * @param   pte a long containing the position of the next char of the last char.
 * @retval txt a string
 * @retval lineFrom a long
 * @retval lineTo   a long
 */
txt lineFrom lineTo txtParser_GetLine( void txtParserFile,  void pts,  void pte) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1411

/**
 * Skip space and comment but not doc comment.
 * @param  txtParserFile a struct containing the text of the file and aditional statistic.
 * @param   ptr a long containing the current position.
 * @return  ptr a long containing the new     position.
 */
ptr txtParser_SkipBlcExeptDoc( void txtParserFile,  void ptr) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1434

/**
 * Check if the string is a syntax correct name.
 * @param  name (L.char)
 * @return  bad bool
 */
bad txt_NameIsBad( void name) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1450

/**
 * Check if the string is alphanumerical.
 * @param   (L.char)
 * @return  bool
 */
bool isAlphaNum( void UNK) {}
//level=1 fn=C:\206-3_11\devLibRlab\src\sys\txtParser.c li=1462

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibRlab\src\sys\txtParser.c
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\CONSOLEVIEW_Export.cpp
// END of C:\206-3_11\libConsoleView\src\CONSOLEVIEW_Export.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\console.cpp
// END of C:\206-3_11\libConsoleView\src\console.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp
/**
 * @addtogroup rlab_console
 * @{
 */
//level=1 fn=C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp li=13

/**
 * Efface le buffer de la console.
 */
clc() {}
//level=1 fn=C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp li=18

/**
 * Show console widget.
 * @param title *L.char*
 */
osConsoleShow( void title) {}
//level=1 fn=C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp li=29

/**
 * Hide console widget.
 */
osConsoleHide() {}
//level=1 fn=C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp li=40

/**
 * @}
 * @addtogroup rlab_editor
 * @{
 */
//level=1 fn=C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp li=52

/**
 * Launch the text file editor.
 * Ouvre le fichiers definissant la fonction script func_name_ dans l'editeur
 * ouvre le fichiers fname_ specifier dans l'editeur integre
 * @param fname1 the string conatining a valid file path or a valid function name
 * @param l *long*  the optional line number for a file (default=1)
 * @param c *long*  the optional column number for a file (default=1)
 * @param autoCompile *long*  the optional flag to compile on save (default=1)
 * @param ... the same, again.
 */
edit( void fname1,  void l,  void c,  void autoCompile,  void ...) {}
//level=1 fn=C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp li=60

/**
 * True if the file fn is currently opened by the text editor.
 * @param fname1 the string conatining a valid file path or a valid function name
 * @return b
 */
b isEdited( void fname1) {}
//level=1 fn=C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp li=115

/**
 * Save all edited file.
 */
editSaveAll() {}
//level=1 fn=C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp li=134

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\libConsoleView\src\libConsoleViewWrapper\CONSOLEVIEW_Wrapper.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stedit.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stedit.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stedlgs.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stedlgs.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stedlgs_wdr.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stedlgs_wdr.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\steexprt.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\steexprt.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stefindr.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stefindr.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\steframe.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\steframe.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stelangs.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stelangs.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stemenum.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stemenum.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stenoteb.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stenoteb.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\steopts.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\steopts.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\steprefs.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\steprefs.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\steprint.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\steprint.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\steshell.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\steshell.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stesplit.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stesplit.cpp
//-------------------------------------------------
// start of C:\206-3_11\libConsoleView\src\wxstedit\src\stestyls.cpp
// END of C:\206-3_11\libConsoleView\src\wxstedit\src\stestyls.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\scp_plot\plot.cpp
/**
  @addtogroup GUI
  @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\plot.cpp li=1

/**
 * Activate the zoom fonctionality of the axes.
 * *ax* is the id of an axes, given by axes() or gca().
 * @param ax
 */
zoom( void ax) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\plot.cpp li=37

/**
 * Plot a complex list.
 * {@include $$plotOpt}
 * @param z *L.cpx*
 * @param opt *L.char*
 * @param ax *long*
 * @return h *long*
 * @return ax *long*
 */
h ax plotz( void z,  void opt,  void ax) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\plot.cpp li=64

/**
 * Plot a double list.
 * {@include $$plotOpt}
 * @param x *double*
 * @param y *double*
 * @param opt *L.char*
 * @param ax *long*
 * @return h *long*
 * @return ax *long*
 */
h ax plotxy( void x,  void y,  void opt,  void ax) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\plot.cpp li=113

/**
 * Plot a double or complex list.
 * depending of number of input, plot is dispatch :
 *   (*)plot(z) => plotz(z)
 *   (*)plot(z,'opt') => plotz(z,'opt')
 *   (*)plot(x,y) => plotxy(x,y)
 *   (*)plot(z,'opt',ax) => plotz(z,'opt',ax)
 *   (*)plot(x,y,'opt') => plotxy(x,y,'opt')
 *   (*)plot(x,y,'opt',ax) => plotxy(x,y,'opt',ax)
 *
 * {@include $$plotOpt}
 * @param x *double*
 * @param y *double*
 * @param opt *L.char*
 * @param ax *long*
 * @return h *long*
 * @return ax *long*
 */
h ax plot( void x,  void y,  void opt,  void ax) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\plot.cpp li=131

/**
 Display a rob screen
 @param idrob *long* or ip *L.char* or lidrob *L.long*
 @note Use pref `radio_TCPIP` (strn of rob IP, rob1 in place 1...) or `debug_IP` (strn of rob IP, rob1 in place 0...)
*/
agvConnect( void idrob) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\plot.cpp li=196

/**
 * Enable zoom limit.
 * @param uiaxes Id of axes graphic control.
 * @param minVal *long* Minimal value in meter.
 * @param maxVal *long* Maximal value in meter.
 */
zoomLimitEnable( void uiaxes,  void minVal,  void maxVal) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\plot.cpp li=284

/**
 * Disable zoom limit.
 * @param gAxes Id of axes graphic control.
 */
zoomLimitDisable( void gAxes) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\plot.cpp li=297

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\scp_plot\plot.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\scp_plot\prefsGrid.cpp
/**
 * @addtogroup GUI
 * @{
 * @addtogroup prefsgrid
 * @{
 */
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\prefsGrid.cpp li=1

/**
 * Fill in a grid with a varspc content
 * @param pg grid id
 * @param v varspc to parse
 */
prefsGridFromVarspc( void pg,  void v) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\prefsGrid.cpp li=28

/**
 * Returns an empty preferences grid (just plain old grid with two columnds
 * labeled 'Propriete' and 'Valeur')
 * @return gid *long* grid id
 */
gid prefsGrid() {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\prefsGrid.cpp li=55

//Kiwi auto close bracket!
/**
 * @}
 * @}
 */
// END of C:\206-3_11\devLibUiObj\scp_plot\prefsGrid.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\scp_plot\svg.cpp
/**
   @addtogroup GUI
   @{
   @addtogroup svg SVG importer
    Import autocad files under .svg format.
    Having an autocad plan displayed on kiwi axes view is helpful to draw the
    circuit accurately.
    Importing a .svg file in Kiwi is straightforward but generating the file is
    the hard part, here is a quick guide about how to proceed:
    - install PDFCreator <http://sourceforge.net/projects/pdfcreator/>
    - open the native autocad .dwg file with DWG TrueView
    <http://usa.autodesk.com/products/>
    - hide all layers containing information that have no interest for you : the
    lighter the better.
    - open the <em>Print</em> dialog and select following attributes :
      - printer: <em>PDFCreator</em>
      - plot area: <em>Window</em> then select region of interest with mouse
    - press <em>OK</em> and select <em>svg</em> as output format

    @note once imported in Kiwi it may happen that the svg content is displayed
    flipped/rotated. This can be fixed:
       1. try to apply a rotation in Kiwi's SVG import window
       1. if still flipped, change the view in DWG TrueView
       (*View > Named views... > Preset views > Bottom > Set current*).
       Reexport and reimport in Kiwi.
       1. if still flipped, open svg file in
       [DraftSight](http://www.3ds.com/fr/products/draftsight/overview/), use
       mirror tool to flip the content, saved flipped dwg and open it in
       DWG TrueView. Reexport and reimport in Kiwi.

    @note when opening a .svg in Kiwi, a cache .svg.obj is created alongside
    original file to speed up future imports. It's important to invalidate the
    cache when modifying a svg file **by removing corresponding .svg.obj file.**
 */
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\svg.cpp li=1

/**
   Load svg file located at \a svgpath and draw it on \a axe.
   A progress dialog is displayed during the process.
   @param axe
   @param svgpath svg file path
 */
svg( void axe,  void svgpath) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\svg.cpp li=254

/**
   Draw a svg file content on an axe.
   <tt>svgLoad(w->axe, load('warehouse.svg.obj'))</tt>
   @param axe
   @param svgobj *varspc*
 */
svgLoad( void axe,  void svgobj) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\svg.cpp li=323

/**
   Open a svg file import dialog
 */
svgDialog() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\svg.cpp li=383

/**
   @internal
   Reset button clicked
 */
svgResetCbk() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\svg.cpp li=523

/**
   @internal
   Import button clicked
 */
svgImportCbk() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\svg.cpp li=545

/**
   @internal
   Transformation control changed
 */
svgRedrawCbk() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\svg.cpp li=582

/**
   @internal
   Apply transformation and delete bounding box
 */
svgCloseCbk() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\svg.cpp li=630

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\scp_plot\svg.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp
/**
   @addtogroup GUI
   @{
   @addtogroup grid
   @{
 */
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=1

/**
   Colorize grid rows using alternating blue/white colours.

   @param gid grid id
   @param startCol column index to start from
 */
gridColorizeRows( void gid,  void startCol) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=8

/**
   Smart grid constructor to build a grid in one single call.

   Perform calls to grid() + gridCreateGrid(). The grid size is dynamically
   from \a rowHeaders and \a colHeaders size.
   Default labels are hidden when \a rowHeaders/colHeaders are empty lists.

   @param parent parent panel
   @param rowHeaders rows headers labels
   @param colHeaders columns headers labels
   @param selMode selection mode : 'CELLS' or 'ROWS'
   @return grid id
 */
grid gridBasicCreate( void parent,  void rowHeaders,  void colHeaders,  void selMode) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=33

/**
   Advanced update grid function.
   Use integer to print binary info in the grid:
     - 1 is replaced by "ON" printed on green background
     - 0 is replaced by "OFF" printed on red background

   @param gridId grid id
   @param cellsContent {{row0_col0, ..., row0_colN}, ..., {rowM_col0, ..., rowM_colN}}
                       with <em>N=number of cols</em> and <em>M=number of rows</em>
   @param colFun *L.char* (optional) callback function name to map cell content
   to color. callback signature:
   [r,g,b]=cbk(cell_value, col_idx) with :
        - cell_value: cell value in lower case
        - col_idx : cell column index
        - [r,g,b] : rgb triplet, each component in the [0,255] interval
   @note If a row have more column than the grid, the additional column are ignored.
   @see gridSetRowLabelValue() to update content of label cells
 */
gridBasicUpdate( void gridId,  void cellsContent,  void colFun) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=69

/**
   Update a row in a grid

   @param gridId grid id
   @param rowNum id of the row to update in the grid. If it's equal to the
   number of rows in the grid, a new row is added
   @param rowContent {col0, ..., colN}
                       with <em>N=number of cols</em>
   @param color (optional) of type :
      - *{color0, ..., colorN}* map cell content to color or
      - *L.char* callback to call that takes cell content and column index as
        parameters and return the color
 */
gridUpdateRow( void gridId,  void rowNum,  void rowContent,  void color) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=136

/**
   Update a col in a grid

   @param gridId grid id
   @param idx id of the row to update in the grid. If it's equal to the number of rows in the grid, a new row is added
   @param rowContent {col0, ..., colN}
                       with <em>N=number of cols</em>
   @param rowColors {color0, ..., colorN} (optional) map cell content to color
 */
gridUpdateCol( void gridId,  void idx,  void rowContent,  void rowColors) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=172

/**
   Delete rows after specified row in the grid

   @param gridId grid id
   @param rowNum id of the row
 */
gridDelRowsAfter( void gridId,  void rowNum) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=195

/**
   Delete columns after specified col in the grid
   @param gridId grid id
   @param colNum id of the col
 */
gridDelColsAfter( void gridId,  void colNum) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=212

/**
   Return color deduced from cell content.

   @param val cell content string
   @param column (ignored here)
 */
gridGetColorForCell( void val,  void column) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=225

/**
   Sort grid rows based on value of nth cell of each row.
   The cell index to consider for the sort is fetched from the grid \a sortCol
   object attribute.
   If grid's \a flipRows attribute is \c1 then rows are sorted then the list is
   flipped and returned.

   @param gid grid id.
   @param rows rows to sort
   @return rows {{cell1row1,...}...{cell1rown,...}} sorted rows list
 */
rows gridSortRows( void gid,  void rows) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=248

/**
   Select the row whose col-th column content equals given key.

   @param gid grid id
   @param key
   @param col column to consider (default: -1. key is extracted from row label)
 */
gridSelectRowFromKey( void gid,  void key,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=276

/**
   Get key identifying selected row.

   @param gid grid id
   @param col column from which text will be extracted. Values in these column
   should be unique so that each value can be used as a key to restore selected
   row (default: -1. key is extracted from row label)
   @return key *L.char*  text identifying the row
 */
key gridGetSelectedRowKey( void gid,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=306

/**
   Return row and column indexes the first rightmost cell visible on screen.

   @param gid grid id
   @return coord *[long,long]* cell coords
 */
coord gridGetLastVisibleCol( void gid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=326

/**
   Switch content of given rows.
   @param gid grid id
   @param rowIdx1
   @param rowIdx2
 */
gridSwitchRows( void gid,  void rowIdx1,  void rowIdx2) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=358

/**
   Add row to selected rows if it was not, remove it if it was already selected.
   @param gid grid id
   @param row
   @return new row index in the selection
 */
new gridSwitchRowSelection( void gid,  void row) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=381

/**
   Label left mouse button click handler.
   It updates sort attributes of
   grid so that rows will be sorted after clicked label at the next update.
   @param gid
   @param row clicked row index
   @param col clicked column index
   @return b \c 1 if a valid label has been clicked or \c 0

   To call in your own \a labelLeftClickCbk before updating the grid.
   @code
   set(grid, 'labelLeftClickCbk', 'myLabelClickedCbk');

   export function myLabelClickedCbk(row,col) {
      global w(get(gco,'gvar'));
      if(gridLabelClickedCbk(gid,row, col)) {
          if(myUpdateGrid(gco)) sizerLayout(w->box->mybox->sizer);
      }
   }
   @endcode
 */
b gridLabelClickedCbk( void gid,  void row,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp li=404

//Kiwi auto close bracket!
/**
 * @}
 * @}
 */
// END of C:\206-3_11\devLibUiObj\scp_plot\wGrid.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp
/**
   @addtogroup GUI
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=1

/**
   Set focus on given editText and select the text.
 */
setFocusAndSelText() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=6

/**
   Generic callback handler to close dialog on close button push.
 */
dialogCloseCbk() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=16

/**
   Returns True if the given button is the one toggled on.
 */
wbgIsButOn() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=28

/**
   Toggle a button from the group.
   Toggled button is painted with a different background color than the others,

   @param buttons all buttons of the group
   @param but button to toggle
 */
wbgSelectBut( void buttons,  void but) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=38

/**
   Get selected button from buttons group.

   @param buttons all buttons of the group
 */
wbgGetSelectedBut( void buttons) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=58

/**
   Iterate over buttons and toggle first enabled button starting from current
   toggled button.

   @param buttons all buttons of the group
 */
wbgSelectNextBut( void buttons) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=74

/**
   Compute ticks number from calendar and hour lineedits.

   @param box parent varspc
 */
getPlannedTicks( void box) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=151

/**
   Calendar date changed callback.
 */
calendarCbk() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=168

/**
   Helper function to ease the construction of a calendar with hour picker.
   @param box parent varspc
   @param parent parent widget
 */
calendarHour( void box,  void parent) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=180

/**
   Executes a function in a different thread, while freezing a widget,
   typically used to avoid reentrant calls.
   *fnc* is passed *gco* as first argument.
   Disable \a widget, call \a fnc with \a args and re-enable \a widget.
   @note thread is automatically killed when *fnc* call is done

   @param widget *long* widget to disable while fnc is running
   @param fnc *L.char* function to call
   @param args *L* *optional* fnc arguments

 */
cbkExe( void widget,  void fnc,  void args) {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=217

/**
   @internal
 */
cbkExe_thread() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=240

/**
    Return horizontal sizer containing label+widget
*/
labelWidget() {}
//level=1 fn=C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp li=270

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\scp_plot\wutils.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\defObj.cpp
/**
 * @addtogroup GUI
 * @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=12

/**
 * Is object having \a id as identifier a GUI object?
 * @param id *long* object identifier
 * @return bool *long*  \c 1 if id corresponds to a gui object
 */
bool isobj( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=538

/**
 * Return GUI ids matching given \a params
 *
 * <tt>objs = findobj(str_param1, val1, str_param2, val2)</tt> with:
 * @param str_param the name of a 'uiobj' object field
 * @param val field value to match
 * @return ids *long*  all GUI ids when no argument given, otherwise returns the ids matching
 * given parameters
 *
 * @code
 * idx = findobj; // return all GUI obj identifier.
 * idx = findobj('type',str_type,'tag',str_tag,'parent',id_parent);
 * @endcode
 */
ids findobj( void str_param,  void val) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=551

/**
 * Find the top parent of a GUI obj.
 * @param id *long* GUI object identifier
 */
findFirstParent( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=586

/**
 * Find children recursively.
 * @param id *long* GUI object identifier
 * @param field_1 field of uiobj
 * @param val_1 field value to match
 * @param ...
 * @param field_n
 * @param val_n
 *
 * @return idxs *long*  children identifiers
 */
idxs findChildren( void id,  void field_1,  void val_1,  void ...,  void field_n,  void val_n) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=599

/**
 * Delete GUI objs
 * No error is generated on wrong ids, ie ids that would have been already deleted.
 *
 * @param ids *[long]* a list of uiobj identifier
 */
delete( void ids) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=628

/**
 * Modify the specified field(s) of an uiObject.
 *
 * <tt>set(id_uiobj, field1, arg1, ..., fieldN, argN) </tt> with:
 * @param id_uiobj *long*  an uiobj identifier
 * @param field   (string) a field name 'children' for exemple
 * @param arg     (type depend on the field) the new value to set
 */
set( void id_uiobj,  void field,  void arg) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=652

/**
 * Get returns the value *val* associated to *field* in the uiobj *id_uiobj*
 * When called with id_uiobj as single argument it prints on the console all
 * the fields/value of the specific object and return \c null.
 *
 * @param id_uiobj (scalar) an uiobj identifier
 * @param field *string*  a field name
 * @return val
 */
val get( void id_uiobj,  void field) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=670

/**
 * Drawnow forces an graphic update of the specified uiObject.
 * ()Call<code>  "(wxWindow*)->Refresh(); (wxWindow*)->Update();" </code>
 * @param id (scalar) id of an uiObj derivatibg from a wxWindow (allmost all uiObj)
 */
drawnow( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=988

/**
 * winFreeze locked an graphic update of the specified uiObject.
 * @param id (scalar) id of an uiObj derivatibg from a wxWindow (allmost all uiObj)
 */
winFreeze( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=1003

/**
 * winThaw unlocked an graphic update of the specified uiObject.
 * winThaw should be called the same number of time than winFreeze.
 * @param id (scalar) id of an uiObj derivatibg from a wxWindow (allmost all uiObj)
 */
winThaw( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=1016

/**
 * winSetFocus give focus to the specified uiObject.
 * @param id (scalar) id of an uiObj derivating from a wxWindow (allmost all uiObj)
 */
winSetFocus( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=1029

/**
 * Layout a sizer controled window.
 * winLayout invokes the constraint-based layout algorithm or the sizer-based
 * algorithm for this window.
 * ()Call "(wxWindow*)->Layout();"
 * @param id a long identifier of an uiObj derivating from a uiWindow (allmost all uiObj)
 */
winLayout( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=1041

/**
 * Return the id of the uiObject whose is executing the callback.
 * Work the same way as this in c++.
 * @return long *object* identifier or \c 0 if not inside a callback
 */
long gco() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=1259

/**
 * Set the current callback running script as reentrant.
 * Do nothing out of a callback runtime.
 * \warning use carefully.
 */
setReentrant() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=1273

/**
 * Return all the fonts name available on the current computer.
 * @return fontnames *L.string*
 *
 * @code
 * fontGetAll() => {'@Arial Unicode MS','@MS Mincho','SansSerif'}
 * @endcode
 */
fontnames fontGetAll() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\defObj.cpp li=1287

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\defObj.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\fieldTool.cpp
/**
 * @addtogroup GUI
 * @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\fieldTool.cpp li=11

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\fieldTool.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp
/**
 * @addtogroup GUI
 * @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp li=10

/**
   Create a line and return its GUI id.

   @param id_obj *long* axes or group where to draw
   @param markerBrush.color *[r,g,b]* (long 0-255) (optional) or in write mode val=0x00rrggbb or val='GREY','WHITE','PINK'
   @param markerBrush.style *string* (optional) 'SOLID','TRANSPARENT'
   @param markerPen.color *[r,g,b]* (long 0-255) (optional) or in write mode val=0x00rrggbb or val='GREY','WHITE','PINK'
   @param markerPen.width *long* (optional)
   @param markerPen.style *string* (optional) 'SOLID', 'TRANSPARENT', 'DOT', 'LONG_DASH', 'DOT_DASH'
   @param markerSize *long* (optional)
   @param pen.color *[r,g,b]* (long 0-255) (optional) or in write mode val=0x00rrggbb or val='GREY','WHITE','PINK'
   @param pen.width *long* (optional)
   @param pen.style *string* (optional) 'SOLID', 'TRANSPARENT', 'DOT', 'LONG_DASH', 'DOT_DASH'
   @param zdata *[cpx,cpx]* (optional) coords

   Example:

           line(145,'markerBrush.color','GREEN','zdata',[cpx(0,1),cpx(3,3)])

  @see uiobj and graphic for inherited fields descriptions
 */
line( void id_obj,  void UNK,  void UNK,  void UNK,  void UNK,  void UNK,  void markerSize,  void UNK,  void UNK,  void UNK,  void zdata) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp li=637

/**
   An easy way to format line option.
   @param optStr *L.char* a combination of the following letter:
   - line color style :
        - 'b' BLUE.
        - 'g' GREEN.
        - 'r' RED.
        - 'c' CYAN.
        - 'm' MAGENTA.
        - 'y' YELLOW.
        - 'k' BLACK.
        - 'w' WHITE.
        - 'p' PURPLE.
   - line size style :
        - '0' size=0.
        - '1' size=1. (default)
        - '2' size=2.
        - '3' size=3.
        - '4' size=4.
        - '5' size=5.
        - '6' size=6.
        - '7' size=7.
        - '8' size=8.
        - '9' size=9.
   - line style style :
        - ' ' No drawing.
        - '-' Continuous. (default)
        - ':' Hashed.
   - line dot style :
        - '.' filled cercles.
        - 'o' empty cercles.
        - 'x' crosses dots.
        - '*' stars dots.

   @return opt *L.varspc*
 */
opt lineStyle( void optStr) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp li=668

/**
  Create a patch and returns its GUI id.

  @param id_obj *long* axes or group where to draw
  @param brush.color *[r,g,b]* (long 0-255) (optional) or in write mode val=0x00rrggbb or val='GREY','WHITE','PINK'
  @param brush.style *string* (optional) 'SOLID','TRANSPARENT'
  @param pen.color *[r,g,b]* (long 0-255) (optional) or in write mode val=0x00rrggbb or val='GREY','WHITE','PINK'
  @param pen.width *long* (optional)
  @param pen.style *string* (optional) 'SOLID', 'TRANSPARENT', 'DOT', 'LONG_DASH', 'DOT_DASH'
  @param zdata *val* (optional) poly coords

  Example:

          patch(145,'brush.color','GREEN','pen.width',3)

  @see uiobj and graphic for inherited fields descriptions
*/
patch( void id_obj,  void UNK,  void UNK,  void UNK,  void UNK,  void UNK,  void zdata) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp li=972

/**
   Create a rectangle and return its GUI id.

   @param id_obj *long* axes or group where to draw
   @param brush.color *[r,g,b]* (long 0-255) (optional) or in write mode
   val=0x00rrggbb or val='GREY','WHITE','PINK'
   @param brush.style *string* (optional) 'SOLID','TRANSPARENT'
   @param pen.color *[r,g,b]* (long 0-255) (optional) or in write mode
   val=0x00rrggbb or val='GREY','WHITE','PINK'
   @param pen.width  *long* (optional)
   @param pen.style *string* (optional) 'SOLID', 'TRANSPARENT', 'DOT', 'LONG_DASH', 'DOT_DASH'
   @param zdata *cpx* (optional)  center coords
   @param dim *cpx* (optional) width and height
   @param cap *cpx* (optional)
   @param label *L.char* (optional)
   @param arrow *long* (optional) if \c 1, draw an arrow in the rect

   Example:

           rectangle(145,'dim',cpx(4,2),'arrow',0,'zdata',cpx(4.3,6))

   @see uiobj and graphic for inherited fields descriptions
 */
rectangle( void id_obj,  void UNK,  void UNK,  void UNK,  void UNK,  void UNK,  void zdata,  void dim,  void cap,  void label,  void arrow) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp li=1116

/**
   Create a text and returns its GUI id.

   @param id_obj *long* axes or group where to draw
   @param color *[r,g,b]* (long 0-255) (optional) or in write mode val=0x00rrggbb or val='GREY','WHITE','PINK'
   @param bkgNone *bool* (optional) transparent or colored background
   @param bkgColor *[r,g,b]* (long 0-255) (optional) or in write mode val=0x00rrggbb or val='GREY','WHITE','PINK'
   @param font ? (optional) lst_fontDesc
   @param string *L.char* (optional)
   @param sizeDyn *float* (optional) define how fonct react when zooming/unzooming the view
   Example:

           text(145,'color','GREEN','string','Hello!')

   @see uiobj and graphic for inherited fields descriptions
 */
text( void id_obj,  void color,  void bkgNone,  void bkgColor,  void font,  void string,  void sizeDyn) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp li=1275

/**
   id = bitmap(id_axes,'fieldN',val_fieldN,...)
   creat a text and return its GUI id.

   Creation Parameter
   (*) id_axes : axes where to draw

   See 'Fuiobj' and 'Fgraphic' and 'Fbitmap' for field Desc.
 */
bitmap() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp li=1460

/**
  id = bitmapBuffer(id_axes,'fieldN',val_fieldN,...)
   creat a text and return its GUI id.

   Creation Parameter
   (*) id_axes : axes where to draw

   See 'Fuiobj' and 'Fgraphic' and 'FbitmapBuffer' for field Desc.
 */
bitmapBuffer() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp li=1526

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiAxDraw.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiAxes.cpp
/**
 * @addtogroup GUI
 * @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=14

/**
   Creates an axes and return its GUI id.

   @param id_parent parent identifier

   Fields :
   - freeze *long*
   - equal *long*
   - ech *[float,float]*
   - keyboardCbk *L.char*
   - mouseDownCbk *L.char*
   - mouseDragCbk *L.char*
   - mouseUpCbk *L.char*
   - mouseWhellCbk *L.char*
   - xlim *[float,float]* x axis range
   - ylim *[float,float]* y axis range
   - z *cpx* center

   @note use zoom() to activate zooming behaviour
 */
axes( void id_parent) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=1289

/**
  id=gca();
  return the identifier of the last created axes
 */
gca() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=1322

/**
   Return the button of a mouse that generate an 'mouseDownCbk' in an 'axes' object.
   In an AXES mousse callback return the pushed button
   res could be on of the following string:
      (*) 'LEFT'
      (*) 'MIDDLE'
      (*) 'RIGHT'
      (*) 'DB_LEFT'
      (*) 'DB_MIDDLE'
      (*) 'DB_RIGHT'
   generate an error if called outside a mouse callback.
   @return str
 */
str mouseButton() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=1333

/**
   z = mouseGetz();
   in an AXES mousse callback return the position of the pointer in local coord
   z is scalar complex
   generate an error if called not inside a mouse callback.
 */
mouseGetz() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=1357

/**
   [k,pnt] = mouseCalcPixDist({ [] , []},dpixMax,surfDetect);
   in an AXES mousse callback return the disyance from the pointer in pixel dist coord
   a is complex
   b is complex
   generate an error if called not inside a mouse callback.
 */
mouseFindNearestPolyLine() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=1374

/**
   Gets the position of the mouse in pixels.
   @return pixelPosition as a complex
 */
pixelPosition mouseGetzPix() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=1488

/**
   lz = axesGetBox(id_axes);
   id_axes : axes identifier
   lz = [cpx(xmin,ymin),cpx(xmax,ymax)]
 */
axesGetBox() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=1503

/**
   axesCopy(id_axes);
   id_axes : axes identifier
   Copy cuurent view to the clipboard.
 */
axesCopy() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=1542

/**
  Connect to a linux agv remote screen.
  Example :
  @verbatim
        export function ttt() {
            fig = win('clientSize',[80*9,25*16]);
            vga = vga437(fig,'ip','192.168.0.100:4442');
            tid = exe("tttUpdate",{vga});
            set(fig,'closeCbk',sprintf("killscp(%i); delete(gco);",tid));
        }
        function tttUpdate(vga) { while(1) { wait(25); vga437update(vga); } }
 @endverbatim
 */
vga437() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=2321

/**


*/
vga437update() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxes.cpp li=2347

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiAxes.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiAxesGL.cpp
/**
 * @addtogroup GUI
 * @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxesGL.cpp li=14

/**
 */
linesGL() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxesGL.cpp li=643

/**
 */
triangleGL() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxesGL.cpp li=710

/**
 */
pointsGL() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxesGL.cpp li=750

/**
 */
imageGL() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiAxesGL.cpp li=875

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiAxesGL.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiCtrl.cpp
/**
   @addtogroup GUI
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=10

/**
   Create a button and return its GUI id.
    ~~~~
    b1 = button(win,'style','RIGHT','title','OK')
    b2 = button(win,'title','OK','cbk','buttonPushed')
    ~~~~

   @param id parent GUI id
   @param style *L.char* 'style' (optional)
   @param str_style *L.char* (if and only if previous *style* parameter is present)
   text alignment, one of
       - 'LEFT'
       - 'TOP'
       - 'RIGHT'
       - 'BOTTOM'
       - 'EXACTFIT'
       - 'NO_BORDER'
   @param title *L.char* (optional)
   @param cbk *string* (optional)

   Other optional fields:
    - bkgColor *color* default: [ 236, 233, 216]
    - enable *long* default: 1
    - fgColor *color* default: 'BLACK'
    - minSize *L.long* default: [-1,-1]
    - show *long* default: 1
    - tooltip *L.char*
 */
button( void id,  void style,  void str_style,  void title,  void cbk) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=109

/**
   buttonSetDefault(id_but)

   This sets the button to be the default item for the panel or dialog box.

   Parameters :
   @param id_but *long*  a button identifier
 */
buttonSetDefault( void id_but) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=174

/**
   Enable or disable an individual button.

   @param id_radio \a long a button identifier
   @param enable \a long \c 0 to disable or \c 1 to enable
 */
buttonEnable( void id_radio,  void enable) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=197

/**
   Create a bitmap button and return its GUI id.

   @param id parent GUI id
   @param style 'style'
   @param str_style \a string one of
       - 'LEFT'
       - 'TOP'
       - 'RIGHT'
       - 'BOTTOM'
       - 'EXACTFIT'
       - 'NO_BORDER'
   @param bitmap bitmap path
   @param cbk : val = string

   Fields:
    - 'cbk' \a string
    - 'fontPointSize' \a long
 */
bitmapButton( void id,  void style,  void str_style,  void bitmap,  void cbk) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=304

/**
   Create a slider and return its GUI id.

   @param id_parent GUI id
   @param style 'style' string (optional)
   @param str_style (only if 'style' is passed) a combination of flags ('opt1|opt2')
   amongst :
       - 'HORIZONTAL'
       - 'VERTICAL'
       - 'AUTOTICKS'
       - 'LABELS'
       - 'LEFT'
       - 'RIGHT'
       - 'TOP'
       - 'BOTTOM'
       - 'SELRANGE'
       - 'INVERSE'

   Fields:
   - 'range' : val = [long,long]
   - 'cbk' : val = string
   - 'value' : val=long
 */
slider( void id_parent,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=452

/**
   Create a radioBox and return its GUI id.

   @param id_parent GUI id
   @param choices \a string comma separated string of of radio labels
   @param style 'style'
   @param str_style \a string one of \a 'COLS' or \a 'ROWS'

   Fields:
   - 'clickCbk' (string). signature cbk: \a clickCbk(idx)
   - 'label' (string)
   - 'selection' (long)
 */
radioBox( void id_parent,  void choices,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=542

/**
   Enable or disable an individual button in the radiobox.

   @param id_radio \a long a radio box identifier
   @param n the \a button index (start from \c 0) to enable or disable
   @param enable \a long \c 0 to disable or \c 1 to enable
 */
radioBoxEnable( void id_radio,  void n,  void enable) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=592

/**
   Get radioBox selected button.

   @param id_radio \a long a radio box identifier
   @return zero-based position of the selected button
 */
UNK radioBoxGetSelection( void id_radio) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=614

/**
   Create a checkBox and return its GUI id.
    ~~~~
    cb = checkBox(win,'title','My checkbox')
    ~~~~
   @param id_parent GUI id
   @param title_key *L.char* 'title'
   @param title *L.char* title

   Fields :
   - value *long* is the box checked?
   - cbk *L.char*
 */
checkBox( void id_parent,  void title_key,  void title) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=673

/**
   Create a choice and return its GUI id.
   ~~~
   c=choice(win, 'string', {'France','USA'})
   ~~~

   @param id_parent GUI id
   @param string_key *L.char* 'string'
   @param string *L.L.char* list of choices

   Fields:
   - value *long* selection. default: -1
   - cbk *L.char*
 */
choice( void id_parent,  void string_key,  void string) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=832

/**
   Create a listBox and return its GUI id.

   @param id_parent GUI id
   @param style "style" (optional)
   @param str_style (only if "style" is passed) one of :
      - 'SINGLE'
      - 'MULTIPLE'
      - 'EXTENDED'
      - 'HSCROLL'
      - 'ALWAYS_SB'
      - 'NEEDED_SB'
      - 'SORT'

   Fields:
   - 'string' with lst_string (list of strings) eg {'A','B','C'}
   - 'cbk'  : val = string
   - 'DBcbk'  : val = string
   - 'value' : val = int
 */
listBox( void id_parent,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1112

/**
   Fill an array of ints with the positions of the currently selected items.

   @param id *long*  a listBox identifier
   @return idxs *L.long*  selected items indexes
 */
idxs listBoxGetSelections( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1160

/**
   Sets the selection to the given item n or removes the selection entirely if
   n == wxNOT_FOUND.

   @param id *long*  a listBox identifier
   @param id_sel *long*  item index
 */
listBoxSetSelection( void id,  void id_sel) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1187

/**
   Sets font for a listBox element

   @param id *long*  a listBox identifier
   @param font *char*  font name ('Courier', 'Arial', ...)
 */
listBoxSetFont( void id,  void font) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1211

/**
   Create a spinCtrl and return its GUI id.
 *
   @param id_parent GUI id
   @param style "style" (optional)
   @param str_style (only if "style" passed) one of
       - 'HORIZONTAL'
       - 'VERTICAL'
       - 'ARROW'
       - 'WRAP'

   Fields :
   - 'range' : val = [long,long]
   - 'value' : val=long
   - 'cbk' : val = string
 */
spinCtrl( void id_parent,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1267

/**
   Create a spinButton and return its GUI id.

   @param id_parent GUI id
   @param style "style" (optional)
   @param str_style one of
       - 'LEFT'
       - 'TOP'
       - 'RIGHT'
       - 'BOTTOM'
       - 'EXACTFIT'
       - 'NO_BORDER'

   Fields:
   - 'range' : val = [long,long]
   - 'cbk' : val = string
   - 'value' : val=long
 */
spinButton( void id_parent,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1410

/**
   Create a editText and return its GUI id.

   @param id_parent GUI id
   @param style *L.char*  'style' string
   @param style_val (only if 'style' passed) a combination of 'OPT1|OPT2' :
       - 'PROCESS_ENTER'
       - 'PROCESS_TAB'
       - 'MULTILINE'
       - 'PASSWORD'
       - 'READONLY'
       - 'RICH'
       - 'RICH2'
       - 'AUTO_URL'
       - 'NOHIDESEL'
       - 'HSCROLL'
       - 'LEFT'
       - 'CENTRE'
       - 'RIGHT'
       - 'DONTWRAP'
       - 'CHARWRAP'
       - 'WORDWRAP'
       - 'BESTWRAP'

   Fields:
   - 'changeCbk' : val = string
   - 'enterCbk' : val = string
   - 'fontPointSize' \a long
   - 'killFocusCbk' : val = string
   - 'string' : val = string
 */
editText( void id_parent,  void style,  void style_val) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1612

/**
   Makes the text item editable or read-only.

   @param id *long*  an editText identifier
   @param edit (bool)
 */
editTextSetEditable( void id,  void edit) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1670

/**
   Selects the text starting at the first position up to (but not including)
   the character at the last position.
   If both parameters are equal to -1 all text in the control is selected.

   @param id *long*  an editText identifier
   @param from *long*
   @param to *long*
 */
editTextSetSelection( void id,  void from,  void to) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1692

/**
   Sets the text value and marks the control as not-modified.
   Note that this function will not generate the wxEVT_COMMAND_TEXT_UPDATED event.

   @param id *long*  an editText identifier
   @param val \a text
 */
editTextChangeValue( void id,  void val) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1717

/**
   Creat a treeCtrl and return its GUI id.

   @param id_parent GUI id
   @param str_style a combinasion of ('OPT1|OPT2')
     - EDIT_LABELS: use this style if you wish the user to be able to edit
       labels in the tree control.
     - NO_BUTTONS:  For convenience to document that no buttons are to be drawn
     - HAS_BUTTONS: Use this style to show + and - buttons to the left of parent
                    items.
     - NO_LINES:    Use this style to hide vertical level connectors.
     - FULL_ROW_HIGHLIGHT: Use this style to have the background colour and the
     selection highlight extend over the entire horizontal row of the tree
     control window. (This flag is ignored under Windows unless you specify
     wxTR_NO_LINES as well.)
     - LINES_AT_ROOT: use this style to show lines between root nodes. Only
     applicable if wxTR_HIDE_ROOT is set and wxTR_NO_LINES is not set.
     - HIDE_ROOT    : use this style to suppress the display of the root node,
     effectively causing the first-level nodes to appear as a series of root
     nodes.
     - ROW_LINES    : use this style to draw a contrasting border between
     displayed rows
     - HAS_VARIABLE_ROW_HEIGHT : use this style to cause row heights to be just
     big enough to fit the content. If not set, all rows use the largest row
     height. The default is that this flag is unset. Generic only.
     - SINGLE	For convenience to document that only one item may be selected
     at a time. Selecting another item causes the current selection, if any,
     to be deselected.  This is the default.
     - MULTIPLE	Use this style to allow a range of items to be selected. If a
     second range is selected, the current range, if any, is deselected.
     - EXTENDED	Use this style to allow disjoint items to be selected.
     (Only partially implemented; may not work in all cases.)
     - DEFAULT_STYLE	The set of flags that are closest to the defaults for
     the native control for a particular toolkit.

   Fields:
   - 'value' : val=long
 */
treeCtrl( void id_parent,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1897

/**
   Appends an item to the end of the branch identified by parent, return a new item id.

   @param id_itemParent if -1 delete all exiting items and add a new root item.
   otherwise id_itemParent should have been return by a previous call to this function
 */
treeCtrlAppendItem( void id_itemParent) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1973

/**
   Change the color of a treeCtrl item
   @param id_treectrl
   @param id_item
   @param color \a rgb color
 */
treeCtrlSetItemTextColor( void id_treectrl,  void id_item,  void color) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=1992

/**
   Selects the given item.
   In multiple selection controls, can be also used to deselect a currently
   selected item if the value of select is false.
   @param id_treectrl
   @param id_item
   @param select \c 0 or \c 1
 */
treeCtrlSelectItem( void id_treectrl,  void id_item,  void select) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2013

/**
   This function either behaves the same as Unselect if the control doesn't have
   wxTR_MULTIPLE style, or removes the selection from all items if it does have
   this style.

   @param id_treeCtrl
 */
treeCtrlUnselectAll( void id_treeCtrl) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2042

/**
   Get the mouse position
   @return z position of the mouse (as a complex)
 */
z treeCtrlGetMouseZ() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2059

/**
   Returns the currently selected items.
   This function can be called only if the control has the wxTR_MULTIPLE style.
   @return L.long selected indexes
 */
UNK treeCtrlGetSelection() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2077

/**
   Sorts the children of the given item
   @param id_parent trectrl id
   @param itemId item id
 */
treeCtrlSortChildren( void id_parent,  void itemId) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2103

/**
   Deletes the specified item.
   @param id_parent treeCtrl id
   @param item id to delete
 */
treeCtrlDelete( void id_parent,  void item) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2123

/**
   Create a scrollbar and return its GUI id.

   @param id_parent GUI id
   @param style "style" (optional)
   @param str_style (only if 'style' passed) one of
       - 'HORIZONTAL'
       - 'VERTICAL'
 */
scrollbar( void id_parent,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2177

/**
   Create a notebook and return its GUI id.

   @param id_parent GUI id
   @param style "style" (optional)
   @param str_style if "style" passed, str_style one of
    - NB_TOP
    - NB_LEFT
    - NB_RIGHT
    - NB_BOTTOM
    - NB_FIXEDWIDTH
    - NB_MULTILINE
    - NB_NOPAGETHEME
    - NB_FLAT

   Fields:
   - 'cbk' : val = string
   - selection : val = long
 */
notebook( void id_parent,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2295

/**
   Adds a new page.

   @param id_gui GUI object identifier
   @param id_panel (uiPanel) specifies the new page.
   @param text *str*  specifies the text for the new page.
 */
notebookAddPage( void id_gui,  void id_panel,  void text) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2340

/**
   Returns the currently selected page

   @param id_gui GUI object identifier

   @return idx *long*  selected page index or \c -1 if none was selected.
 */
idx notebookGetSelection( void id_gui) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2371

/**
   Create a choicebook and return its GUI id.

   @param id_parent GUI id
   @param style "style" optional
   @param str_style only if "style" passed one of
    - NB_TOP
    - NB_LEFT
    - NB_RIGHT
    - NB_BOTTOM
    - NB_FIXEDWIDTH
    - NB_MULTILINE
    - NB_NOPAGETHEME
    - NB_FLAT

   Fields:
   - 'cbk' : val = string
 */
choicebook( void id_parent,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2425

/**
   @copydoc notebookAddPage()
 */
choicebookAddPage() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2469

/**
   @copydoc notebookGetSelection()
 */
choicebookGetSelection() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2496

/**
   Create a listbook and return its GUI id.

   @param id_parent GUI id
   @param style "style" (optional)
   @param str_style if "style" passed, str_style one of
    - NB_TOP
    - NB_LEFT
    - NB_RIGHT
    - NB_BOTTOM
    - NB_FIXEDWIDTH
    - NB_MULTILINE
    - NB_NOPAGETHEME
    - NB_FLAT

   Fields:
   - 'cbkchanging' (string). signature cbk: listbook(idx) with idx=page selected before changing
   - 'cbkchanged' (string).  signature cbk: listbook(idx) with idx=page selected
 */
listbook( void id_parent,  void style,  void str_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2562

/**
   listbookAddPage(id_listbook,id_panel,text)
   Adds a new page.

   @param id_listbook *long*
   @param id_panel (uiPanel) specifies the new page.
   @param text *str*  specifies the text for the new page.
 */
listbookAddPage( void id_listbook,  void id_panel,  void text) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2607

/**
   Deletes the specified page, without deleting the associated window.
   @param id_listbook *long*
   @param page *long*
 */
listbookRemovePage( void id_listbook,  void page) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2639

/**
   @copydoc notebookGetSelection()
 */
listbookGetSelection() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2662

/**
   Returns the number of pages in the listbook control.
   @param id_listbook *long*
   @return page index (long)
 */
page listbookGetPageCount( void id_listbook) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2682

/**
   Create a calendar and return its GUI id.

   @param id_parent GUI id

   Fields:
    - 'date': val = long
    - 'ticks': val = long
    - 'cbk' : val = string
 */
calendar( void id_parent) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiCtrl.cpp li=2815

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiCtrl.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiFrame.cpp
/**
   @addtogroup statusBar
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=26

/**
   Create a status bar and returns its GUI id.

   A status bar is a narrow window that can be placed along the bottom of a
   frame to give small amounts of status information.

   @param  frame (long) the parent frame identifier.
   @return id *long* the new GUI identifier.

   Fields:
   - 'fieldsCount' : val = int
 */
id statusBar( void frame) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=31

/**
   Change the layout of a frame status bar.

   @param id *long*  a status bar identifier.
   @param widths (lst_long) a list of fields width in pixel or ratio (negatives)
 */
statusBarSetWidths( void id,  void widths) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=56

/**
   Change the content of a frame status bar.
   @param id *long*  a status bar identifier.
   @param number *long*  the field to set, starting at 0.
   @param txt *str*  the text to display.
 */
statusBarSetText( void id,  void number,  void txt) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=79

/**
   @}
   @addtogroup frame
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=252

/**
   Create a window and return its GUI id.

   <tt>  id = frame(id_parent, 'style', val_style,'pos',[50,50],'size',[800,600])</tt> with:
   @param id_parent (optional) gui id of another gui for a not toplevel frame
   @param 'style'   (optional)
   @param val_style (only if 'style' is passed) a combination of flags
   eg. 'tool|noresize'. Flag choices :
        - 'tool'
        - 'noresize'
        - 'floatOnTop'
        - 'float'
        - 'hidden'

   @param fieldName (optional) name of a field see below
   @param valField  (only if a fieldName is passed)

   @return id_frame

   @copydoc defObjInit()
    - 'resizeCbk' : val = string
    - 'closeCbk' : val = string
    - 'statusBar' : write val = number of fields (long)  read val=idobj (long)
    - 'menuBarCbk' : write val = number of fields (long)  read val=idobj (long)
 */
id_frame win( void id_parent,  void UNK,  void val_style,  void fieldName,  void valField) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=259

/**
   Close the specified dialog or frame GUI obj.
   Do nothing on bad uiobj identifier.

   @param id \a lst_long of dialog or frame gui obj identifiers
 */
close( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=331

/**
   Raises the window to the top of the window hierarchy (z-order).
   @param id window gui identifier
 */
raise( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=362

/**
   Lowers the window to the bottom of the window hierarchy (z-order).
   @param id a long identifier of a GUI obj of type FRAME.
 */
lower( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=388

/**
   Depending on the value of show parameter the window is either shown full screen
   or restored to its normal state.
   @param id a long identifier of a GUI obj of type FRAME
   @param show bool
 */
showFullScreen( void id,  void show) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=403

/**
   Maximizes or restores the window.
   @param id a long identifier of a GUI obj of type FRAME
   @param bool If \c 1, maximizes the window, otherwise it restores it.
 */
maximize( void id,  void bool) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=420

/**
   Sets the icon for this window.
   @param bitmap_string
 */
setIcon( void bitmap_string) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=436

/**
   Return the id of the last created or raised FRAME
   @return  long GUI identifier
 */
long gcf() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=461

/**
   Creat a scrolledWindow and return its GUI id.
   See 'Fuiobj' 'Fwindow' and 'FscrolledWindow' for field Desc.
   @param parentId
   @return panId
 */
panId scrolledWindow( void parentId) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=536

/**
   @}
   @addtogroup panel
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=575

/**
   Create a panel and return its GUI id.

   @param par *long*  parent id
   @return id *long*  panel GUI identifier
 */
id panel( void par) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=581

/**
   @}
   @addtogroup imagePanel
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=679

/**
   Create an image panel and returns its GUI id.
   @param parentId
   @param image filename
   @return image panel identifier
 */
image imagePanel( void parentId,  void image) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=685

/**
   @}
   @addtogroup toolbar
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1053

/**
   Create a toolbar and return its GUI id.

   @param id_frame GUI id of the frame where to create the tool bar
   @param style a combinaison of flags amongst :
       - FLAT:	Gives the toolbar a flat look (Windows and GTK only).
       - DOCKABLE:   Makes the toolbar floatable and dockable (GTK only).
       - HORIZONTAL: Specifies horizontal layout (default).
       - VERTICAL:   Specifies vertical layout.
       - TEXT:	Shows the text in the toolbar buttons; by default only icons
                are shown.
       - NOICONS: Specifies no icons in the toolbar buttons; by default
                  they are shown.
       - NODIVIDER: Specifies no divider (border) above the toolbar (Windows only).
       - NOALIGN: Specifies no alignment with the parent window (Windows only, not very useful).
       - HORZ_LAYOUT: Shows the text and the icons alongside, not vertically
         stacked (Windows and GTK 2 only). This style must be used with wxTB_TEXT.
       - HORZ_TEXT: Combination of wxTB_HORZ_LAYOUT and wxTB_TEXT.
       - NO_TOOLTIPS: Don't show the short help tooltips for the tools when the mouse hovers over them.
       - BOTTOM:Align the toolbar at the bottom of parent window.
       - RIGHT:	Align the toolbar at the right side of parent window.

   @param id_frame
   @param style
   @return long GUI id
 */
long toolbar( void id_frame,  void style,  void id_frame,  void style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1059

/**
 * Add a separator to the toolbar idtb
 * @param toolbar id
 */
toolbarSeparator( void toolbar) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1105

/**
   Add a toolbar control to the toolbar
   @param toolbar \a long id
   @param control \a long id
 */
toolbarControl( void toolbar,  void control) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1121

/**
   Create a button in a toolbar and return its GUI id.

   @param id \a long parent toolbar
   @param style \a str style one of
      - 'NORMAL'
      - 'CHECK'
      - 'RADIO'
   @param bitmap *L.char* image loaded as string. see simxBmp() (for kiwi) or
   getImage() (for PCsol)
   @return id button identifier

   Other optional fields:
   - value *long* \c 1 for pushed
   - enable *long* : val = bool (0/1)
   - cbk *L.char*
   - shortHelp *L.char*
   - longHelp *L.char*


 */
id toolbarButton( void id,  void style,  void bitmap) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1144

/**
   Update the toolbar for modification
   @param id toolbar id
 */
toolbarRealize( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1194

/**
  Sets the default size of each tool bitmap.
  @param id toolbar id
 */
toolbarSetToolBitmapSize( void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1216

/**
   @}
   @addtogroup dialogs
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1306

/**
   Create a dialog window and return its GUI id.

   @param id_parent GUI id of another GUI for a not toplevel dialog or \c 0 for
   a toplevel dialog.
   @param style *string*  'style'
   @param val_style

   Fields:
   - 'closeCbk' : val = string

   @return long id
 */
long dialog( void id_parent,  void style,  void val_style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1312

/**
   Shows a modal dialog. Program flow does not return until the dialog has been
   dismissed

   @param long dialog id
   @param center (optional) do not center the dialog if 0
 */
modal( void long,  void center) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1374

/**
  Ends a modal dialog, passing a value to be returned from
  the wxDialog::ShowModal invocation.
  @param id
  @param retCode
 */
dlgEndModal( void id,  void retCode) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1400

/**
   Sets the identifier to be used as OK button.

   @param id_dlg
   @param id the id mapping to OK button
 */
dlgSetAffirmativeId( void id_dlg,  void id) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1417

/**
   Color choice dialog.
   @param id_frame parent dialog
   @param color preselected color
   @return color selected color
 */
color colorDlg( void id_frame,  void color) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1442

/**
   Dialog that shows a single or multi-line message,
   with a choice of OK, Yes, No and Cancel buttons.

   @param id_frame parent
   @param msg \a string message
   @param title \a string dialog title
   @param options combination of flags 'opt1|opt2...' :
        - 'OK'
        - 'CANCEL'
        - 'YES_NO'
        - 'YES_DEFAULT'
        - 'NO_DEFAULT'
        - 'ICON_EXCLAMATION'
        - 'ICON_HAND'
        - 'ICON_ERROR'
        - 'ICON_QUESTION'
        - 'ICON_INFORMATION'
   @return  b *long* `1` for yes/ok, `0` for no, `-1` for cancel
 */
b messageDlg( void id_frame,  void msg,  void title,  void options) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1514

/**
    File chooser dialog.

   @param id_win parent
   @param str_title dialog title
   @param str_dir preselected directory
   @param str_fname preselected file
   @param str_type types definition string eg 'txt file (*.txt)|*txt'
   @param options 'opt1|opt2...' :
       - 'OPEN'
       - 'SAVE'
       - 'OVERWRITE_PROMPT'
       - 'FILE_MUST_EXIST'
       - 'MULTIPLE'
       - 'CHANGE_DIR'
 @return  string selected path
 */
string fileDlg( void id_win,  void str_title,  void str_dir,  void str_fname,  void str_type,  void options) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1572

/**
  Directory chooser dialog.

  @param id_win parent
  @param str_title dialog title (default: 'Choose a file')
  @param str_dir preselected directory (default : '')
  @param options 'DD_NEW_DIR_BUTTON' (default: 'DD_NEW_DIR_BUTTON')
  @return  string path
 */
string dirDlg( void id_win,  void str_title,  void str_dir,  void options) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1642

/**
   Dialog that requests a one-line text string from the user.

   @param id_win parent
   @param str_msg (default : '')
   @param str_title dialog title (default: 'Enter a string')
   @param str_value (default: '')
   @return str
 */
str textEntryDlg( void id_win,  void str_msg,  void str_title,  void str_value) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1682

/**
   Show a progress bar dialog.

   @param title dialog title
   @param msg dialog message to display
   @param max \a long max dialog value 100
   @param idwin \a long parent
   @param style_options 'opt1|opt2...' with:
    - 'PD_APP_MODAL:  Make the progress dialog modal. If this flag is not given,
   it is only "locally" modal - that is the input to the parent window is disabled,
   but not to the other ones.
    - 'PD_AUTO_HIDE:  Causes the progress dialog to disappear from screen as soon
   as the maximum value of the progress meter has been reached.
    - 'PD_SMOOTH:  Causes smooth progress of the gauge control.
    - 'PD_CAN_ABORT:  This flag tells the dialog that it should have a "Cancel"
   button which the user may press. If this happens, the next call to Update()
   will return false.
    - 'PD_CAN_SKIP:  This flag tells the dialog that it should have a "Skip"
   button which the user may press. If this happens, the next call to Update()
   will return true in its skip parameter.
    - 'PD_ELAPSED_TIME:  This flag tells the dialog that it should show elapsed
   time (since creating the dialog).
    - 'PD_ESTIMATED_TIME:  This flag tells the dialog that it should show estimated
   time.
    - 'PD_REMAINING_TIME:  This flag tells the dialog that it should show remaining
   time.

   @return  long idobj
 */
long progressDialog( void title,  void msg,  void max,  void idwin,  void style_options) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1733

/**
   Update a progress bar dialog.

   @param id \a long dialog gui id
   @param value \a long the new value of the progress meter.
   @param newmsg \a string new message
   @return ok \a long \c 1 if ok or \c 0 if cancel button clicked
 */
ok progressDialogUpdate( void id,  void value,  void newmsg) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1788

/**
   Switch the gauge to indeterminate mode (if required) and makes the gauge
   move a bit to indicate the user that some progress has been made.
   @param id \a long dialog gui id
   @param newmsg \a string new message
   @return ok \a long \c 1 if ok or \c 0 if cancel button clicked
 */
ok progressDialogPulse( void id,  void newmsg) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1809

/**
   Just like progressDialogUpdate() but makes the gauge control run in indeterminate
   mode

   @param id \a long
   @param newmsg \a string new message
 */
setCursor( void id,  void newmsg) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1865

/**
   HSV to RGB color system conversion
   @param hsv *L.double* hsv triplet with each component in [0,1]
   @return rgb
 */
rgb HSVtoRGB( void hsv) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1891

/**
   Get screen size
   @return cpx
 */
cpx getDisplaySize() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1909

/**
    Determines whether the wxWindow::Layout function will be called automatically
    when the window is resized.
    @param b *bool*
*/
winSetAutoLayout( void b) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1924

/**
    Similar to Fit, but sizes the interior (virtual) size of a window.
*/
winFitInside() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1942

/**
    Sizes the window so that it fits around its subwindows.
*/
winFit() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiFrame.cpp li=1957

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiFrame.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiGrid.cpp
/**
   @addtogroup GUI
   @{
   @addtogroup grid
   @{
 */
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=10

/**
   Create a grid
   Call gridCreateGrid after this to initialize the grid before using it.

   @param id_parent (optional) gui id of another gui for a not toplevel frame
   @param ...
   @return grid id
 */
grid grid( void id_parent,  void ...) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=158

/**
   Creates a grid with the specified initial number of rows and columns.
   Call this directly after the grid constructor.

   @param id_grid *long* a grid identifier.
   @param num_rows *long* number of rows
   @param num_cols *long* number of columns
   @param sel_mode *str* selection mode, one of
       - 'CELLS'
       - 'ROWS'
       - 'COLS'
       - 'ROWS_OR_COLS'
 */
gridCreateGrid( void id_grid,  void num_rows,  void num_cols,  void sel_mode) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=197

/**
  Set the selection behaviour of the grid.
   @param id_grid *long* a grid identifier.
   @param sel_mode *str* selection mode, one of
       - 'CELLS'
       - 'ROWS'
       - 'COLS'
       - 'ROWS_OR_COLS'
*/
gridSetSelectionMode( void id_grid,  void sel_mode) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=227

/**
   Automatically sets the height and width of all rows and columns to fit
   their contents.

   @param id_grid *long* a grid identifier.
 */
gridAutoSize( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=251

/**
   Automatically sets the width of all columns to fit
   their contents.

   @param id_grid *long* a grid identifier.
 */
gridAutoSizeColumns( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=281

/**
   Returns the total number of grid rows.

   @param id_grid *long* a grid identifier.
   @return number of rows
 */
number gridGetNumberRows( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=298

/**
   Returns the total number of grid columns.

   @param id_grid *long* a grid identifier.
   @return number of cols
 */
number gridGetNumberCols( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=315

/**
   Set the value for the given row label.

   @param id_grid *long* a grid identifier.
   @param id_row *long* a row index
   @param val (text) label value
 */
gridSetRowLabelValue( void id_grid,  void id_row,  void val) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=331

/**
   Returns the specified row label.

   @param id_grid *long* a grid identifier.
   @param id_row *long* a row index
   @return  string row label text
 */
string gridGetRowLabelValue( void id_grid,  void id_row) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=350

/**
   Returns the specified col label.

   @param id_grid *long* a grid identifier.
   @param id_col *long* a col index
   @return  string column label text
 */
string gridGetColLabelValue( void id_grid,  void id_col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=369

/**
   Set the value for the given column label.

   @param id_grid *long* a grid identifier.
   @param id_col *long* a column index
   @param val (text) label value
 */
gridSetColLabelValue( void id_grid,  void id_col,  void val) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=388

/**
   Returns the background colour of the cell at the specified location.
   @param id_grid *long* a grid identifier
   @param id_col *long* a col index
   @param col (lst_long) a rgb triplet. Valid RGB values are in the range 0 to 255.
*/
gridGetCellBackgroundColour( void id_grid,  void id_col,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=406

/**
   Set background color of cell at given location.

   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @param id_col *long* a column index
   @param col (lst_long) a rgb triplet. Valid RGB values are in the range 0 to 255.
 */
gridSetCellBackgroundColour( void id_grid,  void id_row,  void id_col,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=426

/**
   Set selection background color.

   @param id_grid *long* a grid identifier
   @param col (lst_long) a rgb triplet. Valid RGB values are in the range 0 to 255.
*/
gridSetSelectionBackground( void id_grid,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=450

/**
   Set selection foreground color.

   @param id_grid *long* a grid identifier
   @param col (lst_long) a rgb triplet. Valid RGB values are in the range 0 to 255.
*/
gridSetSelectionForeground( void id_grid,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=468

/**
   Makes the cell at the specified location read-only or editable.

   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @param id_col *long* a column index
   @param readOnlyFlag *long* \c 1 to make the cell read only
 */
gridSetCellReadOnly( void id_grid,  void id_row,  void id_col,  void readOnlyFlag) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=486

/**
   Is the cell in read-only mode?

   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @param id_col *long* a column index
   @return b \c 1 if cell is read-only or \c 0
 */
b gridIsReadOnly( void id_grid,  void id_row,  void id_col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=509

/**
   Sets the horizontal and vertical alignment for grid cell text at the specified location.

   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @param id_col *long* a column index
   @param horiz *string* horizontal alignment
   @param vert *string* vertical alignment
 */
gridSetCellAlignment( void id_grid,  void id_row,  void id_col,  void horiz,  void vert) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=550

/**
   Appends one or more new rows to the bottom of the grid.

   @param id_grid *long* a grid identifier.
   @param nb_rows *long* number of rows to append
 */
gridAppendRows( void id_grid,  void nb_rows) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=581

/**
   Appends one or more new columns to the right of the grid.

   @param id_grid *long* a grid identifier.
   @param nb_cols *long* number of cols to append
 */
gridAppendCols( void id_grid,  void nb_cols) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=596

/**
   Deletes one or more rows from a grid starting at the specified position

   @param id_grid *long* a grid identifier.
   @param pos *long* index of the first row to delete
   @param nb_rows *long* number of rows to delete
 */
gridDeleteRows( void id_grid,  void pos,  void nb_rows) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=613

/**
  Deletes one or more columns from a grid starting at the specified position.

   @param id_grid *long* a grid identifier.
   @param pos *long* index of the first col to delete
   @param nb_cols *long* number of cols to delete
 */
gridDeleteCols( void id_grid,  void pos,  void nb_cols) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=631

/**
   Sets the string value for the cell at the specified location.
   Cell is not modified if it already contains specified value to avoid flickering.

   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @param id_col *long* a column index
   @param val (text) cell value
   @param force *long* flag to force cell write even when cell content is
   unchanged
   @return b \c 1 if cell value has been changed
 */
b gridSetCellValue( void id_grid,  void id_row,  void id_col,  void val,  void force) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=649

/**
   Returns the string contained in the cell at the specified location.

   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @param id_col *long* a column index
   @return  string cell text
 */
string gridGetCellValue( void id_grid,  void id_row,  void id_col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=682

/**
   Sets the width of the specified column.

   @param id_grid *long* a grid identifier
   @param id_col *long* a column index
   @param width *long*
 */
gridSetColSize( void id_grid,  void id_col,  void width) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=704

/**
   Returns the width of the specified column.

   @param id_grid *long* a grid identifier
   @param id_col *long* a column index
 */
gridGetColSize( void id_grid,  void id_col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=722

/**
   Returns the height of the specified row.
 *
   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @return  long row height
 */
long gridGetRowSize( void id_grid,  void id_row) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=740

/**
   Brings the specified cell into the visible grid cell area with minimal scrolling.
   Does nothing if the cell is already visible.

   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @param id_col *long* a column index
 */
gridMakeCellVisible( void id_grid,  void id_row,  void id_col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=758

/**
   Returns true if a cell is either wholly visible or at least partially
   visible in the grid window.

   @param id_grid *long* a grid identifier
   @param id_row *long* a row index
   @param id_col *long* a column index
   @param wholeCellVisible *long*
   @return b \c 1 if cell is visible or \c 0
 */
b gridIsVisible( void id_grid,  void id_row,  void id_col,  void wholeCellVisible) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=779

/**
   Returns an array of selected rows.
   @see http://aubedesheros.blogspot.com/2009/10/cellules-selectionnees-dune-wxgrid.html

   @param id_grid *long* a grid identifier
   @return idxs *L.long* selected rows indexes
 */
idxs gridGetSelectedRows( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=805

/**
   Returns an array of selected cols.

   @param id_grid *long* a grid identifier
   @return idx *L.long* indexes of selected columns
 */
idx gridGetSelectedCols( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=869

/**
   Returns an array of singly selected cells.

   @param id_grid *long* a grid identifier
 */
gridGetSelectedCells( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=893

/**
   If the edit argument is false this function sets the whole grid as read-only.
   If the argument is \c 1 the grid is set to the default state where cells may
   be editable.
 *
   @param id_grid *long* a grid identifier
   @param edit (bool)
 */
gridEnableEditing( void id_grid,  void edit) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=917

/**
   Clears all data in the underlying grid table and repaints the grid.

   @param id_grid *long* a grid identifier
 */
gridClearGrid( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=937

/**
   Deselects all cells that are currently selected.

   @param id_grid *long* a grid identifier
 */
gridClearSelection( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=952

/**
   Returns the current edited cell.
   @param id_grid *long* a grid identifier
   @return row *long* row index
   @return col *long* column index
 */
row col gridGetCursor( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=967

/**
   Set the current edited cell.
   This may be is catched By a grid select cell callback.
   @param id_grid *long* a grid identifier
   @param row
   @param col
 */
gridSetCursor( void id_grid,  void row,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=984

/**
   Set the font size.
   if nargin == 2 => set default font size.
   Set font size for a specific cell otherwise.
   @param id_grid *long* a grid identifier
   @param row
   @param col
   @param fontsize
 */
gridSetCellFontSize( void id_grid,  void row,  void col,  void fontsize) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1009

/**
   Set the font style.
   if nargin == 3 => set default font size.
   Set font size for a specific cell otherwise.
   @param id_grid *long* a grid identifier
   @param row
   @param col
   @param style
 */
gridSetCellFontStyle( void id_grid,  void row,  void col,  void style) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1059

/**
   Set the font color.
   if nargin == 2 => set default font color.
   Set font color for a specific cell otherwise.
   @param id_grid *long* a grid identifier
   @param row
   @param col
   @param fontColor
 */
gridSetCellFontColor( void id_grid,  void row,  void col,  void fontColor) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1102

/**
   Get the font color.
   Get font color for a specific cell otherwise.
   @param id_grid *long* a grid identifier
   @param row
   @param col
   @return fontColor
 */
fontColor gridGetCellFontColor( void id_grid,  void row,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1133

/**
   Sets the default horizontal and vertical alignment for grid cell text.
   @param id_grid *long* a grid identifier
   @param horiz *string* horizontal alignment
   @param vert *string* vertical alignment
 */
gridSetDefCellsAlignment( void id_grid,  void horiz,  void vert) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1155

/**
   Selects the specified row.
   @param id_grid *long* a grid identifier
   @param rowIdx *long* row to select
   @param addToSelected *long* if \c 0 then any existing selection will be deselected.
 */
gridSelectRow( void id_grid,  void rowIdx,  void addToSelected) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1178

/**
   Selects the specified column.
   @param id_grid *long* a grid identifier
   @param colIdx *long* col to select
   @param addToSelected *long* if \c 0 then any existing selection will be deselected.
 */
gridSelectCol( void id_grid,  void colIdx,  void addToSelected) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1195

/**
   Selects the specified block cells col,row.
   @param id_grid    *long* a grid identifier
   @param topRow     *long* first row to select
   @param leftCol    *long* first col to select
   @param bottomRow  *long* last  row to select
   @param rightCol   *long* last  col to select
   @param addToSelected *long* if \c 0 then any existing selection will be deselected.
 */
gridSelectBlock( void id_grid,  void topRow,  void leftCol,  void bottomRow,  void rightCol,  void addToSelected) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1214

/**
   Increments the grid's batch count.
   Code that does a lot of grid modification can be enclosed between gridBeginBatch
   and gridEndBatch calls to avoid screen flicker.
 *
   @param id_grid *long* a grid identifier
 */
gridBeginBatch( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1242

/**
   Decrements the grid's batch count.
   Code that does a lot of grid modification can be enclosed between gridBeginBatch()
   and gridEndBatch() calls to avoid screen flicker.
   The final gridEndBatch() will cause the grid to be repainted.
 *
   @param id_grid *long* a grid identifier
 */
gridEndBatch( void id_grid) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1260

/**
   Sets the choice editor for the grid cell at the specified location.
   @param id_grid *long* a grid identifier
   @param row *long* row index
   @param col *long* column index
 */
gridSetCellChoiceEditor( void id_grid,  void row,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1278

/**
   Sets editor for floats at the specified location.
   @param id_grid *long* a grid identifier
   @param row *long* row index
   @param col *long* column index
 */
gridSetCellFloatEditor( void id_grid,  void row,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1301

/**
   Sets editor for integers at the specified location.
   @param id_grid *long* a grid identifier
   @param row *long* row index
   @param col *long* column index
   @param parameters (optional) number range. string format is "min,max".
 */
gridSetCellNumberEditor( void id_grid,  void row,  void col,  void parameters) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1321

/**
   Sets editor for string/text data at the specified location.
   @param id_grid *long* a grid identifier
   @param row *long* row index
   @param col *long* column index
 */
gridSetCellTextEditor( void id_grid,  void row,  void col) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiGrid.cpp li=1346

//Kiwi auto close bracket!
/**
 * @}
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiGrid.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiHtml.cpp
// END of C:\206-3_11\devLibUiObj\src\uiHtml.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiMenu.cpp
/**
   @addtogroup GUI
   @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiMenu.cpp li=9

/**
   Creates a menu.
   @param winId parent window index
   @param title menu title (optional)
   @return menuId
 */
menuId menu( void winId,  void title) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiMenu.cpp li=113

/**
   Creates a menu item
   @param menuId *long* parent menu id
   @param label *L.char* menuItem label
   @param style *L.char* (optional) 'style' followed by one of 'SEPARATOR','NORMAL',
   'CHECK','RADIO'
   @return id *long*
 */
id menuItem( void menuId,  void label,  void style) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiMenu.cpp li=155

/**
 * Script function, creates a separator at the end of a menu
   @param menuId parent menu index
 */
menuSeparator( void menuId) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiMenu.cpp li=191

/**
   Script function, pops up a menu
   @param menuId parent menu index
   @param x menu x position
   @param y menu y position
 */
popupMenu( void menuId,  void x,  void y) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiMenu.cpp li=209

/**
  Create a menu bar
   @param id_win parent window
   @return id_menu
 */
id_menu menubar( void id_win) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiMenu.cpp li=317

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiMenu.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiObj.cpp
/**
 * @addtogroup GUI
 * @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiObj.cpp li=4

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiObj.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiSizer.cpp
/**
  @addtogroup GUI
  @{
    @addtogroup sizers Sizers
    @{
       sizers are used for laying out subwindows in a window.
       The layout algorithm used by sizers in wxWidgets is closely related to layout
       in other GUI toolkits, such as Java's AWT, the GTK toolkit or the Qt toolkit.
       It is based upon the idea of the individual subwindows reporting their
       minimal required size and their ability to get stretched if the size of the
       parent window has changed. This will most often mean that the programmer
       does not set the original size of a dialog in the beginning, rather the
       dialog will be assigned a sizer and this sizer will be queried about the
       recommended size. The sizer in turn will query its children, which can
       be normal windows, empty space or other sizers, so that a hierarchy of
       sizers can be constructed. Note that wxSizer does not derive from wxWindow
       and thus does not interfere with tab ordering and requires very little
       resources compared to a real window on screen.

       @see http://docs.wxwidgets.org/2.8/wx_sizeroverview.html
 */
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=10

/**
   Appends a child to the sizer.

   @param id_sizer *long* sizer obj identifier
   @param id_obj *long* sizer obj identifier or *[long,long]* dimension to add
        to the sizer
   @param strech *long* strech weight coefficient. (helpful if more then one
           stechable item to change the stech proportion behaviour). default:0
   @param flag *L.char* 'OPT1|OPT2' a combination of :
       - borders flags :
           - T   TOP
           - B   BOTTOM
           - L   LEFT
           - R   RIGHT
           - ALL     // all the previous -> specifies where borders applies
       - other flags :
           - EXPAND
           - SHAPED
           - FIXED_MINSIZE
       - alignement flags :
           - AC  ALIGN_CENTER
           - AL  ALIGN_LEFT
           - AR  ALIGN_RIGHT
           - AT  ALIGN_TOP
           - AB  ALIGN_BOTTOM
           - ACV  ALIGN_CENTER_VERTICAL
           - ACH  ALIGN_CENTER_HORIZONTAL
 */
sizerAdd( void id_sizer,  void id_obj,  void strech,  void flag) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=152

/**
   Same as sizerAdd, but prepends the items to the beginning of the list of
    items (windows, subsizers or spaces) owned by this sizer.

   @param id_sizer *long* sizer obj identifier
   @param id_obj *long* sizer obj identifier or *[long,long]* dimension to add
        to the sizer
   @param strech *long* strech weight coefficient. (helpful if more then one
           stechable item to change the stech proportion behaviour). default:0
   @param flag *L.char* 'OPT1|OPT2' a combination of :
       - borders flags :
           - T   TOP
           - B   BOTTOM
           - L   LEFT
           - R   RIGHT
           - ALL     // all the previous -> specifies where borders applies
       - other flags :
           - EXPAND
           - SHAPED
           - FIXED_MINSIZE
       - alignement flags :
           - AC  ALIGN_CENTER
           - AL  ALIGN_LEFT
           - AR  ALIGN_RIGHT
           - AT  ALIGN_TOP
           - AB  ALIGN_BOTTOM
           - ACV  ALIGN_CENTER_VERTICAL
           - ACH  ALIGN_CENTER_HORIZONTAL
 */
sizerPrepend( void id_sizer,  void id_obj,  void strech,  void flag) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=221

/**
   Removes a sizer
   @param mySizer father sizer containing a child sizer
   @param sizerToRemove child sizer to remove
 */
sizerRemove( void mySizer,  void sizerToRemove) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=291

/**
   Removes a sizer
   @param mySizer father sizer containing a child sizer
   @param pos *long* position of the child in the sizer
 */
sizerRemoveIdx( void mySizer,  void pos) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=313

/**
   Tell the sizer to resize the window to match the sizer's minimal size.
   For a top level window this is the total window size, not client size.
   @param sizer *long*
   @param window *long*
 */
sizerFit( void sizer,  void window) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=335

/**
   Tell the sizer to resize the virtual size of the window to match the sizer's minimal size.
   This will not alter the on screen size of the window, but may cause the addition/removal/alteration of
   scrollbars required to view the virtual area in windows which manage it.
   @param sizer *long*
   @param window *long*
 */
sizerFitInside( void sizer,  void window) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=354

/**
   This method first calls Fit and then SetSizeHints on the windowpassed to it.
   This only makes sense when window is actually a wxTopLevelWindow such as a wxFrame or a wxDialog,
   since SetSizeHints only has any effect in these classes.  It does nothing in normal windows or controls.
   @param sizer *long*
   @param window *long*
 */
sizerSetSizeHints( void sizer,  void window) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=375

/**
   Set sizer and fit window, same as :
            set(id_win,'sizer',id_sizer);
            sizerFit(id_sizer,id_win);
            sizerSetSizeHints(id_sizer,id_win);
   @param sizer *long*
   @param window *long*
 */
winSetSizerAndFit( void sizer,  void window) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=396

/**
   Adds a spacer to a sizer.
   @param sizerId
   @param size
 */
sizerAddSpacer( void sizerId,  void size) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=417

/**
   Adds a stretch spacer to a sizer.
   @param sizerId
   @param stretchFactor (optional)
 */
sizerAddStretchSpacer( void sizerId,  void stretchFactor) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=436

/**
   Set a sizer item proportion
   @param sizerId
   @param item index
   @param proportion
 */
sizerSetItemProportion( void sizerId,  void item,  void proportion) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=455

/**
   Set a sizer item flag
   @param sizerId
   @param item index
   @param flags
 */
sizerSetItemFlag( void sizerId,  void item,  void flags) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=475

/**
   Shows or hides an element in the sizer.
   @param sizerId
   @param subElement (window or sizer)
   @param show if 1 shows, else hides
   @param recursivly if 1 shows or hides recursivly children
 */
sizerShow( void sizerId,  void subElement,  void show,  void recursivly) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=499

/**
   Call this to force layout of the children anew, e.g. after having added a child to or
   removed a child (window, other sizer or space) from the sizer while keeping the current dimension.
   @param sizerId
 */
sizerLayout( void sizerId) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=530

/**
   Create a sizer and return its GUI id.
   @param style *L.char* 'VERTICAL' or 'HORIZONTAL' or shortcut 'V' or 'H'
   @return sizer id
 */
sizer boxSizer( void style) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=563

/**
   Create a staticbox sizer and return its GUI id.

   @param id_fig *long* existing staticbox id or parent window id
   @param style *L.char* 'VERTICAL' or 'HORIZONTAL' or shortcut 'V' or 'H'
   @param name *L.char* (optional) label name only considered if first param is a
     window identifier
 */
staticBoxSizer( void id_fig,  void style,  void name) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=590

/**
   Creation Parameters :
   @param id_sizer *long*  a sizer identifier.
   @param label (text) the new box label
 */
staticBoxSizerSetBoxLabel( void id_sizer,  void label) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=625

/**
   id=gridSizer('Cols',cols,'Rows',row,'HGab',HGab,'VGab',VGab);

   creat a gridSizer and return its GUI id.

   Creation Parameter

   See 'Fuiobj' 'Fsizer' 'FgridSizer' for field Desc.
 */
gridSizer() {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=663

/**
   id=flexGridSizer(style);

   creat a flexGridSizer and return its GUI id.

   Creation Parameter

   See 'Fuiobj' 'Fsizer' 'FgridSizer' for field Desc.
 */
flexGridSizer() {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=698

/**
   id=stdDialogButtonSizer();
 *
   creat a stdDialogButtonSizer and return its GUI id.
 *
   Creation Parameter
 *
   See 'Fuiobj' 'Fsizer' 'FgridSizer' for field Desc.
 */
stdDlgButSizer() {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=725

/**
   id=stdDlgButSizerAddButton(id_dlg, id_but)
 *
   Adds a button to the wxStdDialogButtonSizer
   Creation Parameters:
 *
   @param id_dlg *long*
   @param id_but *long*
 */
stdDlgButSizerAddButton( void id_dlg,  void id_but) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=743

/**
   id=stdDlgButSizerSetAffirmativeButton(id_dlg, id_but)
 *
   Creation Parameters:
   @param id_dlg *long*
   @param id_but *long*
 */
stdDlgButSizerSetAffButton( void id_dlg,  void id_but) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=766

/**
   id=stdDlgButSizerSetCancelButton(id_dlg, id_but)
 *
   Creation Parameters
   @param id_dlg *long*
   @param id_but *long*
 */
stdDlgButSizerSetCancelButton( void id_dlg,  void id_but) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=786

/**
   id=stdDlgButSizerRealize(id_dlg)
 *
   Rearranges the buttons and applies proper spacing between buttons to make them
   match the platform or toolkit's interface guidelines.
   Creation Parameters:
 *
   @param id_dlg *long*
 */
stdDlgButSizerRealize( void id_dlg) {}
//level=2 fn=C:\206-3_11\devLibUiObj\src\uiSizer.cpp li=808

//Kiwi auto close bracket!
/**
 * @}
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiSizer.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiStatic.cpp
/**
 * @addtogroup GUI
 * @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiStatic.cpp li=9

/**
 * id = staticText(id_parent,str_style,'fieldN',val_fieldN,...)
 *
 * creat a staticText and return its GUI id.
 *
 * Creation Parameter
 * (*) id_parent GUI id
 * (*) str_style one of
 *     'ALIGN_LEFT'
 *     'ALIGN_RIGHT'
 *     'ALIGN_CENTRE'
 *
 * See 'Fuiobj' and 'Fwindow' and 'FstaticText' for field Desc.
 */
staticText() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiStatic.cpp li=48

/**
 * id = staticBox(id_parent,'fieldN',val_fieldN,...)
 *
 * creat a static box and return its GUI id.
 *
 * Creation Parameter
 * (*) id_parent GUI id
 *
 * See 'Fuiobj' and 'Fwindow' for field Desc.
 */
staticBox() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiStatic.cpp li=174

/**
 * id = staticLine(id_parent)
 * id = staticLine(id_parent,style,'fieldN',val_fieldN,...)
 *
 * creat a static line and return its GUI id.
 *
 * Creation Parameter
 * (*) id_parent GUI id
 * (*) style one of :
 *     _ 'HORIZONTAL' or 'H'
 *     _ 'VERTICAL' or 'V'
 *
 * See 'Fuiobj' and 'Fwindow' for field Desc.
 */
staticLine() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiStatic.cpp li=220

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiStatic.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibUiObj\src\uiUtils.cpp
/**
 * @}
 * @addtogroup rlab_string
 * @{
 */
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiUtils.cpp li=11

/**
 * Load a bitmap from a file into a string.
 * @param fileName_bmp_png_xpm
 * @param msk_color
 * @return data
 */
data loadBitmap( void fileName_bmp_png_xpm,  void msk_color) {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiUtils.cpp li=17

/**
 * @internal
 * Force to process the wxEventLoop.
 * Useful during in a long computation, makes the GUI reacting.
 * Written as "wxTheApp->Yield();"
 * Use carefully
 */
yield() {}
//level=1 fn=C:\206-3_11\devLibUiObj\src\uiUtils.cpp li=150

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibUiObj\src\uiUtils.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp
/**
  @internal
  Initialisation de la configuration du capteur ifmO3D
  @param myip *string* adresse IP du chariot
  @param ip *string* adresse IP de la camra 3D
  @return v *varspc* Configuration du capteur
 */
v ifmO3D_new( void myip,  void ip) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp li=19

/**
  @internal
  Fonction permettant de se connecter  la camra ifmO3D
  @param v *varspc* Configuration du capteur
 */
ifmO3D_connect( void v) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp li=48

/**
  @internal
  Fonction permettant demander l'aquisition d'une nouvelle image  la camra ifmO3D
  @param v *varspc* Configuration du capteur
 */
ifmO3D_triggerImage( void v) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp li=80

/**
  @internal
  Fonction permettant de changer le frontend de la camra ifmO3D
  @param v *varspc* Configuration du capteur
 */
ifmO3D_setFrontEnd( void v) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp li=96

/**
  @internal
  Demande son modle  la camra ifmO3D
  @param v *varspc* Configuration du capteur
  @return model *vtx* Le modle du capteur
 */
model ifmO3D_getModel( void v) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp li=134

/**
  @internal
  Effectue la reception des frames de la camra ifmO3D
  @param v *varspc* Configuration du capteur
  @return frame *L.char* Les images de la camra
 */
frame ifmO3D_getFrame( void v) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp li=174

/**
  @internal
  Effectue la dconnection de la camra ifmO3D
  @param v *varspc* Configuration du capteur
 */
ifmO3D_disconnect( void v) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp li=224

// END of C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3dDrv.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp
/**
  @internal
  TODO Fonction permettant de faire un filtre moyenneur sur chaque point du nuage dpendant de la luminosit du point
  @param in_scan *liste de distance* scan d'entre non filtr
  @param in_color *liste d'intensit* L'intensit lumineuse de chaque point
  @return out_scan *liste de distance* Scan filtr de sortie
 */
out_scan color_mean_filter( void in_scan,  void in_color) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=208

/**
  @internal
  Fonction permettant de faire un filtre moyenneur sur chaque point du nuage
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param main_multiplier *int* Le coefficient multiplicateur du moyenneur pour le point courrant
  @param side_multiplier *int* Le coefficient multiplicateur du moyenneur pour les points autour du point courrant
  @return out_vtx *liste de vtx* Nuage de point filtr
 */
out_vtx mean_filter( void in_vtx,  void main_multiplier,  void side_multiplier) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=272

/**
  @internal
  Fonction permettant de les pics sur un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param max_value *double* Hauteur maximale entre 2 points pour ne pas tre considr comme un pic
  @param numb_points *int* Le nombre de points adjacents ncessaire avec lesquels avoir la hauteur max pour ne pas tre un pic
  @param main_multiplier *int* Le coefficient multiplicateur du moyenneur pour le point courrant
  @param side_multiplier *int* Le coefficient multiplicateur du moyenneur pour les points autour du point courrant
  @return out_vtx *liste de vtx* Nuage de point filtr
 */
out_vtx peak_filter( void in_vtx,  void max_value,  void numb_points,  void main_multiplier,  void side_multiplier) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=325

/**
  @internal
  Fonction permettant de supprimer les valeurs ngative en z d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @return out_vtx *liste de vtx* Nuage de point filtr
 */
out_vtx negative_filter( void in_vtx) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=429

/**
  @internal
  Fonction permettant de calculer les normales en chaque point d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @return out_vtx *liste de vtx* Nuage de point des normales
 */
out_vtx normal_filter( void in_vtx) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=448

/**
  @internal
  Fonction permettant de calculer les normales en chaque point d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param min_value *double* Hauteur minimale entre 2 points pour tre considr comme une normale utile
  @return out_vtx *liste de vtx* Nuage de point des normales
 */
out_vtx normal_height_filter( void in_vtx,  void min_value) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=517

/**
  @internal
  Fonction permettant de calculer les normales en chaque point d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @return out_vtx *liste de vtx* Nuage de point des normales
 */
out_vtx color_visu( void in_vtx) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=630

/**
  @internal
  Fonction permettant de saturer les valeurs en z d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param saturation *double* Valeur de saturation
  @return out_vtx *liste de vtx* Nuage de point filtr
 */
out_vtx saturate_z_filter( void in_vtx,  void saturation) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=648

/**
  @internal
  Fonction permettant de mettre  0 les valeurs en z trop haute (cause blouissement) d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @return out_vtx *liste de vtx* Nuage de point filtr
 */
out_vtx remove_infinite_value( void in_vtx) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=668

/**
  @internal
  Fonction permettant de mettre  0 les valeurs en z trop basse (cause blouissement) d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @return out_vtx *liste de vtx* Nuage de point filtr
 */
out_vtx remove_minfinite_value( void in_vtx) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=687

/**
  @internal
  Fonction permettant de mettre  0 les valeurs des zones inhibes
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param in_world *liste de vtx* Nuage de points dans le repre monde
  @return out_vtx *liste de vtx* Nuage de point filtr
 */
out_vtx inhib_zones( void in_vtx,  void in_world) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=706

/**
  @internal
  Fonction permettant de mettre  0 les valeurs de la zone inhibe
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param in_world *liste de vtx* Nuage de points dans le repre monde
  @param in_cpx *cpx* Centre de la zone  inhiber
  @param x_size *double* La taille  regarder de chaque cot du point en X
  @param y_size *double* La taille  regarder de chaque cot du point en Y
  @param z_height *double* La hauteur d'inhibition en Z
  @return out_vtx *liste de vtx* Nuage de point filtr
 */
out_vtx inhib_zone( void in_vtx,  void in_world,  void in_cpx,  void x_size,  void y_size,  void z_height) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=738

/**
  Fonction permettant d'ajouter une zone  inhiber par la camra 3D
  @param in_cpx *cpx* Centre de la zone  inhiber
  @param x_size *double* La taille  regarder de chaque cot autour du centre en X
  @param y_size *double* La taille  regarder de chaque cot autour du centre en Y
  */
add_inhib_zone( void in_cpx,  void x_size,  void y_size) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=769

/**
  @internal
  Function permettant de changer la frquence de modulation de la camra 3D.
  @param modulation *long* Le numro de la modulation (0-2 pour ifmo3d)
 */
secu3D_ChangeModulation( void modulation) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=784

/**
  @internal
  Fonction permettant de valider que l'algorithme thread est termin
 */
secu3D_ComputationDone() {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=795

/**
  @internal
  Function permettant d'activer la rcupration d'images (trigger) de la camra 3D.
  @param modulation *long* Le mode (0 = On ne rcupere pas d'images / 1 = On rcupere des images)
 */
secu3D_SetGetImages( void modulation) {}
//level=0 fn=C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp li=805

// END of C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoCommon.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoRaw.cpp
// END of C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoRaw.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoRideauFacettes.cpp
// END of C:\206-3_11\devLibDrv\scp_ifmo3d\ifmo3d_algoRideauFacettes.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_ifmo3dViewer\ifmo3dViewer.cpp
// END of C:\206-3_11\devLibDrv\scp_ifmo3dViewer\ifmo3dViewer.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_sickDbg\algorithmes.cpp
// END of C:\206-3_11\devLibDrv\scp_sickDbg\algorithmes.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_sickDbg\communication.cpp
// END of C:\206-3_11\devLibDrv\scp_sickDbg\communication.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_sickDbg\sickDbg.cpp
// END of C:\206-3_11\devLibDrv\scp_sickDbg\sickDbg.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_sickDbg\tools.cpp
// END of C:\206-3_11\devLibDrv\scp_sickDbg\tools.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp
/**
 * @addtogroup sick_dbg
 * @{
 */
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=1

/**
 * Particular point detection.
 * Optimized for SFA load feet detection.
 * @param val raw sick value (in cm)
 * @param zdata sick value (complex)
 * @return points
 */
points pointDetection( void val,  void zdata) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=7

/**
 * Finds a pattern in a cloud of points.
 * First point of model must exist.
 * @param points cloud of points
 * @param model *list* of complex defining the patern to look for
 * @param modelLength biggest length of the model (useful for discrimination)
 * @param thetaTolerance
 * @param lengthTolerance
 * @param nbPointTolerance
 * @return res *list* of complex corresponding to found patterns separated by nan
 */
res findPattern( void points,  void model,  void modelLength,  void thetaTolerance,  void lengthTolerance,  void nbPointTolerance) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=43

/**
 * Updates the position and score of a pattern in a cloud of points.
 * @param foot cloud of points
 * @param model pattern to update
 * @param zp pattern list
 * @param lengthTolerance
 * @param nbPointTolerance
 * @return foot initial cloud of points without the feet which were used for updating patterns
 * @return res pattern list updated
 */
foot res updatePattern( void foot,  void model,  void zp,  void lengthTolerance,  void nbPointTolerance) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=117

/**
 * Finds the best (mean square) transformation (translation + rotation) between points and modele.
 * modele_best_position = z + iexp(theta) * modele.
 * @param points complex list
 * @param modele complex list
 * @return z translation
 * @return theta rotation
 */
z theta findTransformation( void points,  void modele) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=177

/**
 * Finds max length of a polynome.
 * @param points polynome definition
 * @return l maximum length
 */
l polyLength( void points) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=207

/**
 * Finds segments from sick data.
 * @param val raw sick value (in cm)
 * @param zdata sick value (complex)
 * @param lengthTolerance max distance between segment and points
 * @param nbPointTolerance min point number to define a segment
 * @param distMin min size of a segment
 * @return zSeg segment list
 */
zSeg segDetection( void val,  void zdata,  void lengthTolerance,  void nbPointTolerance,  void distMin) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=230

/**
 * Matches pattern on a segment.
 * @param segs segment list
 * @param modele pattern to find
 * @param lengthTolerance
 * @param thetaTolerance
 * @return zPal pattern list
 */
zPal segMatching( void segs,  void modele,  void lengthTolerance,  void thetaTolerance) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=320

/**
 * Filters segments that correpond to a modele.
 * @param segs segment list
 * @param modele pattern to find
 * @param lengthTolerance
 * @param thetaTolerance
 * @return zPal pattern list
 */
zPal filterSegments( void segs,  void modele,  void lengthTolerance,  void thetaTolerance) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=346

/**
 * Performs an iterative straight line root min square update.
 * Beginning : updateDrms(cpx(0, 0), cpx(0, 0), 0.0, 0, z);
 * @param z0 previous straight line definition
 * @param ssz internal parameter
 * @param sszb internal parameter
 * @param n number of points
 * @param z point to add
 * @return z0 *str*aight line definition
 * @return ssz internal parameter
 * @return sszb internal parameter
 * @return n new number of point (n = n+1)
 * @return alpha *str*aight line definition
 * @return err standard deviation (sqrt(mean(sq(error))))
 */
z0 ssz sszb n alpha err updateDrms( void z0,  void ssz,  void sszb,  void n,  void z) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=372

/**
 * Same as Drms but using iteractive function updateDrms.
 */
testDrms2() {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=400

/**
 * Same as Drms but in script.
 */
testDrms() {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp li=416

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\detection_algorithmes.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\load_detection.cpp
/**
 * @addtogroup sick_dbg
 * @{
 */
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\load_detection.cpp li=1

/**
 * Finds the load position.
 * Must be lauched in a separate thread.
 * @param g global variable containing the input and outputs
 *      input
 *          sickDrv sick global variable name
 *      output
 *          err error code (valid if > 0)
 *          loadPosition result (valid if != 0)
 */
findLoadPosition( void g) {}
//level=1 fn=C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\load_detection.cpp li=27

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\load_detection.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\testSick.cpp
// END of C:\206-3_11\devLibDrv\scp_sickDbg\testPanel\testSick.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\scp_stm32\bootloaderSTM32.cpp
// END of C:\206-3_11\devLibDrv\scp_stm32\bootloaderSTM32.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\src\bpcan.c
/**
 * @addtogroup drivr_bpcan
 * @{
 */
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=12

/**
 * @internal
 * BPcan drv : open BPcan interfaces.
 * Open cards at given IPs *ethSerCanIP* and expecting *devices* dip switches BPcan card number.
 * @param ethSerCanIP
 * @param devives
 */
bpcanOpen( void ethSerCanIP,  void devives) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=984

/**
 * @internal
 * BPcan drv : close BPcan driver.
 */
bpcanClose() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1008

/**
 * @internal
 * BPcan drv : run the driver.
 * Should be call at 50hz at least.
 * Do the tx and rx on UDP port 6666 and 7777 at inited ethSerCanIP.
 */
bpcanDo() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1024

/**
 * BPcan drv : retrive the value of an input.
 * @param idbpcan *long*
 * - idbpcan = BBE = BPcan_number*10 + Ein_number
 *    - BPcan_number(BB) = 0 to 31 the dip switch value.
 *    - Ein_number   (E) = 1 to 5  the nummpber of the input
 * - idbpcan = EECBBE =  ethSerCanIP_number*10000 + etSerCan_canNumber*1000 +
 *   BPcan_number*10 + Ein_number
 *    - ip_number   (EE) = 0 to any ethSerCan card IP index of the \a ethSerCabIP
 *    parameter given by bpcanOpen()
 *    - can_number   (C) = 1 or 2  the can interface used on ethSerCan card.
 *    - BPcan_number(BB) = 0 to 31 the dip switch value.
 *    - Ein_number   (E) = 1 to 5  the number of the input
 * @retval val *L.long*  \c 1 or \c 0
 * @retval err *L.long*  !=0 if val==0
*/
val err bpcanGetIn( void idbpcan) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1042

/**
 * BPcan drv : retrive the value of an output.
 * Output value are ranged from 1 to 4. Retrieve the last set value.
 * This value might not be already send to the BPcan.
 * @see bpcanGetIn() for arguments description.
 * @param idbpcan *long*
 * @return val *L.long*
 * @return err *L.long*
 */
val err bpcanGetOut( void idbpcan) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1079

/**
 * BPcan drv : set given value of an output.
 * Output value are ranged from 1 to 4.
 * @see bpcanGetIn() for arguments description.
 * @param idbpcan *long*
 * @param  val (L.long) \c 0 => OFF. \c !=0 => ON. This value might not be
 * already send to the BPcan.
 * @return err *L.long*
 */
err bpcanSetOut( void idbpcan,  void val) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1108

/**
 * @internal
 * BPcan drv : retrieve err msg/information about the driver.
 * Updated by bpcanDo.
 * @return msg *L.char*  Null if no error, otherwise a string to display.
 */
msg bpcanGetErr() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1129

/**
 * @internal
 * BPcan drv : return all bpcanId to pass to bpcanGetBpStatut().
 * @return bpcanIds *L.long*
 */
bpcanIds bpcanGetAllBp() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1143

/**
 * @internal
 * BPcan drv : information about a specific BPcan.
 * See bpcanGetAllBp() to find callable id param.
 * @param bpcanId
 * @return info *L.obj*
 * - ipStr : "192.168.1.60"
 * - ipStrColor 'GREEN'/'RED'
 * - bpAdrInfo  'ID (canid=%i dipsw=%i) [ERRMSG]'
 * - bpAdrInfostrColor 'GREEN'/'RED'
 * - bpValue           'in=----- out=----'
 * - bpValueColor       'BLACK'
 */
info bpcanGetBpStatut( void bpcanId) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1156

/**
 * @internal
 * BPcan drv : return all ethId to pass to bpcanGetEthStatut.
 * @return ethIds *L.long*
 */
ethIds bpcanGetAllEth() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1179

/**
 * @internal
 * BPcan drv : information about a specific ip.
 * See bpcanGetAllBp() to find callable id param.
 * @param bpcanId
 * @return info *L.obj*
 * - ipStr : "192.168.1.60"
 * - ipStrColor 'GREEN'/'RED'
 */
info bpcanGetEthStatut( void bpcanId) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1194

/**
 * @internal
 * BPcan drv : raz BPcan driver close every thing and ropen every thing.
 * @deprecated Use RAZComBox() instead.
 */
bpcanRaz() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\bpcan.c li=1214

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibDrv\src\bpcan.c
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\src\halName.c
/**
 @internal

   @param buff
   @return crc
 */
crc halTruckModel2Id( void buff) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\halName.c li=128

// END of C:\206-3_11\devLibDrv\src\halName.c
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\src\hc12.c
/**
 @internal
 * To Be Written.
 * @param
 * @return
 */
UNK hc12Rcv( void UNK) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=319

/**
 @internal
 * To Be Written.
 * @param
 * @return
 */
UNK hc12buffRcv( void UNK) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=366

/**
 @internal
 * To Be Written.
 * @param
 * @return
 */
UNK hc12Snd( void UNK) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=419

/**
 @internal
 * To Be Written.
 * @param
 * @return
 */
UNK hc12buffSnd( void UNK) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=474

/**
 @internal
 * To Be Written.
 * @param
 * @return
 */
UNK hc12Stat( void UNK) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=538

/**
 @internal
 * To Be Written.
 * @param
 * @return
 */
UNK hc12buffClose( void UNK) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=553

/**
 @internal
 * To Be Written.
 * @param
 * @return
 */
UNK hc12buffOpen( void UNK) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=583

/**
 @internal
 * Affiche le contenue d'un packet hc12.
 * @param data
 */
hc12PrintHex( void data) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=620

/**
 @internal
 * Affiche le contenue d'un packet hc12.
 * @param data
 */
hc12Print( void data) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\hc12.c li=639

// END of C:\206-3_11\devLibDrv\src\hc12.c
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\src\ifmo3d.c
/**
  @internal
  Fonction permettant de faire un filtre moyenneur sur chaque point du nuage plusieurs fois d'affil
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param out_vtx *liste de vtx* Nuage de points en sortie
  @param numb_loop *int* Le nombre de boucle de filtrage  effectuer
  @param main_multiplier *int* Le coefficient multiplicateur du moyenneur pour le point courrant
  @param side_multiplier *int* Le coefficient multiplicateur du moyenneur pour les points autour du point courrant
 */
multi_mean_filterC( void in_vtx,  void out_vtx,  void numb_loop,  void main_multiplier,  void side_multiplier) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\ifmo3d.c li=122

/**
  @internal
  Fonction permettant de les pics sur un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param out_vtx *liste de vtx* Nuage de points en sortie
  @param max_value *double* Hauteur maximale entre 2 points pour ne pas tre considr comme un pic
  @param numb_points *int* Le nombre de points adjacents ncessaire avec lesquels avoir la hauteur max pour ne pas tre un pic
  @param main_multiplier *int* Le coefficient multiplicateur du moyenneur pour le point courrant
  @param side_multiplier *int* Le coefficient multiplicateur du moyenneur pour les points autour du point courrant
 */
peak_filterC( void in_vtx,  void out_vtx,  void max_value,  void numb_points,  void main_multiplier,  void side_multiplier) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\ifmo3d.c li=213

/**
  @internal
  Fonction permettant de supprimer les valeurs ngative en z d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param out_vtx *liste de vtx* Nuage de point filtr
 */
negative_filterC( void in_vtx,  void out_vtx) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\ifmo3d.c li=400

/**
  @internal
  Fonction permettant de saturer les valeurs en z d'un nuage de points
  @param in_vtx *liste de vtx* Nuage de points en entre
  @param out_vtx *liste de vtx* Nuage de point filtr
  @param saturation *double* Valeur de saturation
 */
saturate_z_filterC( void in_vtx,  void out_vtx,  void saturation) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\ifmo3d.c li=436

/**
  @internal
  Fonction permettant de savoir si le rsultat du calcul est pret
  @return ready *long* 0 si le rsultat n'est pas pret / 1 si le rsultat est pret
 */
ready isThread3DResReady() {}
//level=0 fn=C:\206-3_11\devLibDrv\src\ifmo3d.c li=540

/**
  @internal
  Fonction permettant de mettre  0 le flag de rsultat pret
 */
initResThread3D() {}
//level=0 fn=C:\206-3_11\devLibDrv\src\ifmo3d.c li=555

/**
  @internal
  La fonction accessible depuis Kiwi permettant d'intragir avec le thread
  @param test *long* La valeur permettant de savoir si c'est une initialisation ou un nouveau calcul
  @param vtx_input *List of vtx* Le nuage de point d'entre
 */
thread3D( void test,  void vtx_input) {}
//level=0 fn=C:\206-3_11\devLibDrv\src\ifmo3d.c li=616

/**
  [points,ts,type] = ifmO3DparseFrame(index,data)
 */
ifmO3DparseFrame() {}
//level=0 fn=C:\206-3_11\devLibDrv\src\ifmo3d.c li=643

// END of C:\206-3_11\devLibDrv\src\ifmo3d.c
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\src\iodrv.c
/**
   @addtogroup drivers
   @{
 */
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=8

/**
   Link a logic(functional name) to a physic io (name of pin of the hardware).
   @param Ilogic
   @param Iphysic
   @return
 */
UNK ioLink( void Ilogic,  void Iphysic) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=852

/**
   Declare a physic input controled by sofware.
   @param Iphysic_name
   @param tmo_in_ms
   @param tmoValue_bool
   @return idVirtualPhysic
 */
idVirtualPhysic ioDeclareVirtualPhysicIn( void Iphysic_name,  void tmo_in_ms,  void tmoValue_bool) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=868

/**
  Set a virtual physic input and retrig tmo (developper side).
   @param IDphysic
  @param value
 */
ioWriteVirtualPhysicIn( void IDphysic,  void value) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=887

/**
   Declare a logic output.
   A script command set outputs using ioWriteOut.
   Nothing append (defValue=1,0) if the logic output is not link to one or more physical output.
   An error occur if defValue is not 1or0, and the output is not linked, ioWriteOut is call on it.
   If private is set to none zero (default is 1), ioWriteOut out can only operate with outLogicId
   @param name
   @param defValue
   @param private
   @return outLogicId
 */
outLogicId ioDeclareOut( void name,  void defValue,  void private) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=904

/**
   Declare a logic input.
   A script command read inputs using ioReadIn.
   Return defvalue (defValue=1,0) if the logic input is not link to one or more physical input.
   An error occur if defValue is not 1or0, and the output is not linked, ioWriteOut is call on it.
   If private is set to none zero (default is zero), ioReadIn can only operate with outLogicId
   @param name
   @param defValue
   @param private
   @return inLogicId
 */
inLogicId ioDeclareIn( void name,  void defValue,  void private) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=932

/**
 Set a logic output.
 A logic output is declared by ioDeclareOut() and linked to some physical output by ioLink().
 Nothing happen (defValue=1,0) if the logic output is not link to one or more physical output.
 An error occurs if defValue is not 1 or 0, and the output is not linked, ioWriteOut is call on it.

       function initMASORTIE {
       ioDeclareOut("MADORTIE",0);
       ioLink("MASORTIE",'optS2');
       }
       export function setMASORTIE(val) {
       ioWriteOut("MADORTIE",val);
       }

  @param name_or_id
  @param val
 */
ioWriteOut( void name_or_id,  void val) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=962

/**
   Read a logic input.
   A logic input is declared by ioDeclareIn() and linked to some physical input by ioLink()
   Nothing append (defValue=1,0) if the logic input is not link to one or more physical input.
   An error occur if defValue is not 1or0, and the input is not linked, ioReadIn is call on it.
   @code

function initMASORTIE {
    ioDeclareIn("MONENTRE",0);
    ioLink("MONENTRE",'optE2');
}

export function setMASORTIE(val) {
    val = ioReadIn("MONENTRE");
}
 @endcode
   @param name_or_id
  @return val
 */
val ioReadIn( void name_or_id) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=1001

/**
   Tell if a logic IO has been linked to a physic IO.
   @param name_or_id
   @param val
 */
ioIsLinked( void name_or_id,  void val) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\iodrv.c li=1040

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibDrv\src\iodrv.c
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\src\lidarDriver.c
/**
 * @addtogroup lidar
 * @{
 */
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=11

/**
 * Open a lidar buffer on a specific ip interface.
 * @param  laserModel(L.char) on of 'S300' 'hokuyo' or 'T10'
 * @param  hardwareAdr(L.char)
 * @param  laserId (L.char)
 * @param  optional_firstRay_id0 (long)
 * @param  optional_lastRay_id1  (long)
 * @return id(long)
 */
UNK lidarOpen( void UNK,  void UNK,  void laserId,  void optional_firstRay_id0,  void optional_lastRay_id1) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3370

/**
 * Close a lidar buffer.
 * @param id(long)
 */
lidarClose( void UNK) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3394

/**
 * Called by kiwi. Do not call from application code.
 */
lidarDrvDo() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3408

/**
 * Get a new Frame from an open laser device.
 * @param id *long*
 * @param refFrame *L.long*
 * @param getLast long
 * @return frame   (L.long)
 */
frame lidarGetFrame( void id,  void refFrame,  void getLast) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3421

/**
 * Get a new Frame from an open lidar device.
 * @param id *long*
 * @param refFrame *L.long*
 * @param getLast long
 * @return frame   (L.long)
 */
frame lidarGetLastFrame( void id,  void refFrame,  void getLast) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3449

/**
 Definit la derniere trame pour un laser virtuel
 @param adress *L.char*
 @param data *L.long*
 */
lidarVirtualSetFrame( void adress,  void data) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3477

/**
 * Display debug information on the console.
 * @param id *long*
 */
lidarInfo( void id) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3543

/**
 * Activate debug information on the console.
 * @param id *long*
 */
setLidarDebugMode( void id) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3554

/**
 * @internal
 * Initialized mutex for non concurent access to pointer.
 * Necessaire pour les threads qui ont besoin d'accder au trame laser
*/
lidarInitThread() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\lidarDriver.c li=3567

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibDrv\src\lidarDriver.c
//-------------------------------------------------
// start of C:\206-3_11\devLibDrv\src\packetRadio.c
/**
  @addtogroup radio
  @{
*/
//level=1 fn=C:\206-3_11\devLibDrv\src\packetRadio.c li=15

/**
Affiche les infos sur toutes les radios ouvertes
*/
radioInfo() {}
//level=1 fn=C:\206-3_11\devLibDrv\src\packetRadio.c li=3005

/**
@internal
Ouvre une radio
@param serDesc *L.char*
@return radid
*/
radid pckradOpen( void serDesc) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\packetRadio.c li=3042

/**
@internal
Ferme une radio
@param radid
*/
pckradClose( void radid) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\packetRadio.c li=3058

/**
@internal
Sniff sur une radio (a appeler rgulirement)
@param radid
@return res *cell* pcks recus
*/
res pckradSniff( void radid) {}
//level=1 fn=C:\206-3_11\devLibDrv\src\packetRadio.c li=3098

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibDrv\src\packetRadio.c
//-------------------------------------------------
// start of C:\206-3_11\devLibPlayer\scp_player\player.cpp
/**
 * @addtogroup player
 * @{
 */
//level=1 fn=C:\206-3_11\devLibPlayer\scp_player\player.cpp li=1

/**
 * Lance l'application player.
 * A appeler sans parametres.
 * @param action
 * @param val
 */
simxPlayer( void action,  void val) {}
//level=1 fn=C:\206-3_11\devLibPlayer\scp_player\player.cpp li=6

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibPlayer\scp_player\player.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibPlayer\src\readHisto.c
/**
  @internal


  Read an histoXXX.txt file has produce by the pcsol application.
  @param fname *L.char*
  @return histo *L.histo*
 */
histo readHisto( void fname) {}
//level=0 fn=C:\206-3_11\devLibPlayer\src\readHisto.c li=345

// END of C:\206-3_11\devLibPlayer\src\readHisto.c
//-------------------------------------------------
// start of C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp
/**
   @addtogroup Event
   @{
 */
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=1

/**
   Launch event thread
  @param loadEventPrefs *long* default : 1. if set to 0 it won't read projectEventDef for events definition. (used for pc clients)
  @return tid *long*
  @note in all cases pref 'eventConf' is read (to set/inhibit warnings on unknown events)
 */
tid eventInit( void loadEventPrefs) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=12

/**
  @internal
  Event main
 */
eventMain() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=164

/**
   Generates an event
   @param category (L.char).
   @param name *L.char*.
   @param param (cell of any type) parameters given to the callbacks.
   @param paramBcst *L.long* parameters given to the callbacks on broadcast.
   @note For all events called by radio from rob, the 1st param (ie param.(0)) is robid, the 5 next ones come from the event itself
   @verbatim
   //Example:
   eventThrow('core','tt',{1,2.,'a',[4,5]},[2,3])
   @endverbatim
 */
eventThrow( void category,  void name,  void param,  void paramBcst) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=265

/**
   Generates a pcClient event
   @param name *L.char*.
   @param param (cell of any type) parameters given to the callbacks on broadcast..
   @note : for all events called by radio from rob, the 1st param (ie param.(0)) is robid, the 3 next ones come from the rob itself
 */
eventPcClientThrow( void name,  void param) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=292

/**
   Defines an event
   @param category *L.char ou varspc*. Category of the event, or varspc with all fields
   @param name *L.char*.
   @param broadcast *long* event has to be broadcasted to pc/rob?
   @param fcts *L.name* functions to call locally when event generated.
   @param fctsBcst *L.name* functions to call on broadcast when event generated
   @param id *long* (optional)
   @param priority *long* priority on the radio stack for broadcasted events. default:5 (optional)
   @return id *long* .
   @note if event already definied, the fcts and fctsBcst will be added to the event
   @verbatim
   //Example :
   eventDef('core','tt',1,strn('eventDisp'),strn('eventDisp'))
   @endverbatim
 */
id eventDef( void category,  void name,  void broadcast,  void fcts,  void fctsBcst,  void id,  void priority) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=446

/**
   Defines an event with
	- category 'pcClient';
	- broadcast 0 (no broadcast to rob)

   @param name *L.char*.
   @param fctsBcst *L.name* functions to call after reception of the event on the partner side

   @return id *long* .
 */
id eventPcClientDef( void name,  void fctsBcst) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=536

/**
   Get the id of an event
   @param category *L.char*.
   @param name *L.char*.
   @param forceName *long* if set to 1 search for the name, even if name is ''.
   @return id *varspc* .
 */
id eventGetId( void category,  void name,  void forceName) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=553

/**
   Links an event to a function.
   Can also link all the events of a category to the function (if name is '')
   @param category *L.char*.
   @param name *L.char*. > set to '' to link the function to all the events of the category
   @param fct *L.name* list of functions to call when event generated
   @return id *long*  id of events modified.
 */
id eventLink( void category,  void name,  void fct) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=582

/**
   Unlinks an event to a function.
   Can also unlink all the events of a category to the function (if name is '')
   @param category *L.char*.
   @param name *L.char*. > set to '' to link the function to all the events of the category
   @param fct *L.name* functions to unlink. set to '' to unlink all the callbacks of the event
   @return id *long*  id of events modified.
 */
id eventUnlink( void category,  void name,  void fct) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=624

/**
   Links an event to a function on broadcast call.
   Can also link all the events of a category to the function (if name is '')
   @param category *L.char*.
   @param name *L.char* use *''* to link the function to all the events of the category
   @param fct *L.name* functions to call when event generated
   @return id *long*  id of events modified.
 */
id eventBcstLink( void category,  void name,  void fct) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=665

/**
   Unlinks an event to a function on broadcast call.
   Can also unlink all the events of a category to the function (if name is '')
   @param category *L.char*.
   @param name *L.char* set to *''* to link the function to all the events of the category
   @param fct *L.name* function to unlink. set to '' to unlink all the callbacks of the event
   @return id *long*  id of events modified.
 */
id eventBcstUnlink( void category,  void name,  void fct) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=717

/**
   Handles the comm events (personal + broadcast of events)
   To call in the main loop
   @param name *string*. name of the event
   @param param (any type) parameters given to the callbacks.
 */
eventRcvCom( void name,  void param) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=799

/**
   @internal
   Handles the pcClient events
   call the functions on reception of the event by the remoteCall
   @param name *string*. name of the event
   @param narg *long*
   @param param (any type) parameters given to the callbacks.
 */
eventRcvPcClient( void name,  void narg,  void param) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp li=836

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibSysCommon\scp_event\eventMain.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibSysCommon\scp_event\testsIntegration.cpp
// END of C:\206-3_11\devLibSysCommon\scp_event\testsIntegration.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibSysCommon\scp_modCommon\doordb.cpp
/**
  @addtogroup door


  @{
*/
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_modCommon\doordb.cpp li=1

/**
  Creates a doorDB and extends its definition if \a attribs are given

  doorDB definition:

*AGV fields*
  - **zoneName**        *strn* zone on the cir representing the door. Must be of canton type
  - **dAsk**            *double* Distance to the door to start opening it (default:8.)
  - **dStop**           *double* Distance to the door at which the rob stops if the door is closed (default:0.5)
  - **checkRate**       *long* Ask if door still open each `checkRate` while the agv is near (or inside) the zone (default:8)
  - **timeBetweenAsks** *double* Time in seconds the agv has to wait until each ask of opening doors (default:4)
  - **doorTMO**         *long* Set door as closed if no answer since
                     `checkRate+doorTMO` seconds (default:17)
  - **slowThroughDoor** *long* Slow down while under the door (default:1)
  - **TMOopening**      *long* Time between opening ask and positive opening answer in second (default:120)
  - **DockingStation**  *long* If door is declared as a docking station, the robot will have the ability to stop in door zone (default:0)

*PCsol fields*
  - **comboxIDIn**    *long* Id of combox entry linked to the state 'door opened'
  - **comboxPortIn**  *long* Port of combox entry linked to the state 'door opened'
  - **comboxIDOut**   *long* Id of combox out opening the door
  - **comboxPortOut** *long* Port of combox out opening the door
  - **z**             *cpx* Position for display of the door
  - **dim**           *cpx* Dimension for display of the door (default:cpx(1,1))
  - **sasId**         *long* Regrouper sous le meme id des portes formant un sas (default:0)

*Internal fields*
  - **id**           *long* internal key field
  - **state**        *long* internal (0:closed, 1:opened, 2:being closed, 3: being opened)
  - **timeOpenDoor** *long* internal
  - **force**        *long* internal
  - **z0**           *long* identifiant de la zone
 */
doorDBdef() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_modCommon\doordb.cpp li=10

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibSysCommon\scp_modCommon\doordb.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibSysCommon\scp_modCommon\modStk.cpp
/**
@addtogroup stk
@{
*/
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_modCommon\modStk.cpp li=1

/**
  Explode a location into idstk, x and y offsets components.
  ~~~~
  stkExplodeLoc(123400100) => [1234,1,0]
  stkExplodeLoc(0)		   => [0,0,0]
  ~~~~
  @param loc location long SSSSXXXYY
  @param check *long* raise error if location does not exist
  @retval idstk *long* [0,999]: rob id, [1000,9999]: line idstk
  @retval x *long* x offset
  @retval y *long* y offset
 */
idstk x y stkExplodeLoc( void loc,  void check) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_modCommon\modStk.cpp li=8

/**
  Build all possible location tokens from location components.
  A location is formatted as `<SSSS><XXX><YY>` with <em>SSSS=idstk,
  XXX=horizontal pal index, YY=vertical pal index</em>
  ~~~
  stkLoc([1234],[1,2],0) => [123400100,123400200]
  ~~~
  @param idstk *L.long* 1-999 refers to rob ids, 1000+ to stock lines
  @param xoff *L.long* (optional) horizontal offset of the pal in the stock line
  (start from 0). default: `0`
  @param yoff *L.long* (optional) vertical offset of the pal in the stock line
   (start from 0). default: `0`
  @return location *L.long*
 */
location stkLoc( void idstk,  void xoff,  void yoff) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_modCommon\modStk.cpp li=41

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibSysCommon\scp_modCommon\modStk.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibSysCommon\scp_rc\gui.cpp
/**
    Return an handle to the main window
*/
mainWindowId() {}
//level=0 fn=C:\206-3_11\devLibSysCommon\scp_rc\gui.cpp li=1

// END of C:\206-3_11\devLibSysCommon\scp_rc\gui.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp
/**
  \if PCsol
  @addtogroup MVC
  @{
  \endif
 */
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp li=1

/**
  \ifnot PCsol @internal
  \else  Init mvc data structures
  \endif
*/
mvcInit() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp li=8

/**
  \ifnot PCsol @internal
  \else
  Check if given db are dirty and broadcast modified keys to clients.
  @param dbnames *str* n field names identifying the dbs in the 'db' global varspc
  @return number of broadcasts done
  @note ignore 'robDB' as parameter to prevent jamming the notifications stack
  (as robDB is contantly updated it's not suited for use with mvc system)
  \endif
 */
number mvcNotifyViews( void dbnames) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp li=24

/**
  @internal
  Client callback for model updates.
  Push db name and modified keys in the events stack.
  This stack is continually popped by *mvcUpdateViews()*.
  @param dbname
  @param dirtyKeys database keys that have been modified
  @note client function
 */
mvcHandleModelChanged( void dbname,  void dirtyKeys) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp li=55

/**
  \ifnot PCsol @internal
  \else
  Register callbacks to execute on clients every time *dbname* is
  modified on server.
  @param dbname *L.char*  watched database
  @param cbks *strn* list of callback functions. Those functions prototypes must
  be `myCbk (w, keys)`
  @note client function
  @note mapUpd[Stk|Pal|Rob|Door]Items callbacks functions are registered by
  createMainWindow_v2
  \endif
 */
mvcConnect( void dbname,  void cbks) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp li=79

/**
  \ifnot PCsol @internal
  \else
  Register callbacks to execute on clients every time *dbname* is
  modified on server and given predicate is satisfied.
  @param dbname *L.char*  watched database
  @param cbks *strn* list of callback functions. Those functions prototypes must
  be `myCbk (w, keys)`
  @param field *L.char* field to consider
  @param op *L.char* operation to apply on field
  @param value *any* value to compare the field with
  @note client function
  \endif
 */
mvcConnectIf( void dbname,  void cbks,  void field,  void op,  void value) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp li=99

/**
  \ifnot PCsol @internal
  \else
  Disconnect cbk from dbname updates
  @param dbname L.char
  @param cbkDisc strn optional. Disconnect all cbks if none given.
  \endif
*/
mvcDisconnect( void dbname,  void cbkDisc) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp li=142

/**
  \ifnot PCsol @internal
  \else
  Get dirty databases keys from server events stack and update views
  accordingly.
  At each call at most 5 messages are popped from the stack. This can be
  customized by set mvc->nbPoppedMsg variable.
  @param forced
     - if \c 1 update all views
     - if \c 0 update only dirty watched views (ie those registered with
     mvcConnect())
  @note client function
  \endif
 */
mvcUpdateViews( void forced) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp li=174

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibSysCommon\scp_rc\mvc.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp
/**
  \if PCsol
  @addtogroup Ntk
  @{
  \endif
*/
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=1

/**
  \ifnot PCsol @internal
  \else  Delete DB entries on DB network server
   @param dbname *strn* DB name
   @param id *L.long* keys to delete
  \endif
*/
ntkDbDel( void dbname,  void id) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=9

/**
  \ifnot PCsol @internal
  \else  Add DB entry on DB network server

   @param dbname *strn* DB name
   @param key *optional* *long*
   @param v *varspc* to add
   @return created key
  \endif
*/
created ntkDbAdd( void dbname,  void key,  void v) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=21

/**
  ifnot PCsol @internal
  \else
   Get DB entry on DB network server

   @param dbname *strn* DB name
   @param keys L.long keys to get
   @param fields *optional* strn* list of fields to get
   @return res *varspc* requested fields or all fields if no *fields* given
  \endif
*/
res ntkDbGet( void dbname,  void keys,  void fields) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=37

/**
  \ifnot PCsol @internal
  \else
   Set DB entry on DB network server

   @param dbname *strn* DB name
   @param key *optional* *long* keys to set
   @param fields *varspc* fields to set
   @return res *L.long* modified keys
  \endif
*/
res ntkDbSet( void dbname,  void key,  void fields) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=54

/**
  \ifnot PCsol @internal
  \else
   Set DB entry on DB network server and create it if it does not exist already.

   @param dbname *strn* DB name
   @param key *optional* *long* keys to set
   @param fields *varspc* fields to set
   @return res *L.long* modified keys
  \endif
*/
res ntkDbAddOrSet( void dbname,  void key,  void fields) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=71

/**
  \ifnot PCsol @internal
  \else
   Find DB entries on DB network server that match given criteria

   @param dbname *strn* DB name
   @param field *strn* field to consider
   @param op *strn* operation to apply on field
   @param value to compare the field with
   @return keys *L.long* found keys
  \endif
*/
keys ntkDbFind( void dbname,  void field,  void op,  void value) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=89

/**
  \ifnot PCsol @internal
  \else
   Get all keys of given network server DB

   @param dbname *strn* DB name
   @return keys *L.long* keys
  \endif
*/
keys ntkDbGetAllKeys( void dbname) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=106

/**
  \ifnot PCsol @internal
  \else
   Get the number of keys of given network server DB

   @param dbname *strn* DB name
   @return nbkeys *long* number of keys
  \endif
*/
nbkeys ntkDbSize( void dbname) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=121

/**
  \ifnot PCsol @internal
  \else
   Create a DB on network server
   Try to load <dbname>.obj or create db from definition if it fails.

   @param dbname *strn* DB name
   @param def *varspc* db fields
   @param key *strn* db primary key
   @param ondisk *optional* *long* save/load .obj on disk if \c 1 (default: \c 1) forced to \c 0 for robs
   @return res *long* \c 1 if db loaded from file or \c 0 if created empty
  \endif
*/
res ntkDbCreate( void dbname,  void def,  void key,  void ondisk) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=135

/**
  \ifnot PCsol @internal
  \else
   Save db named \<dbname\> in a file name \<dbnamed\>.obj.
   @param dbname *strn* DB name
  \endif
*/
ntkDbSave( void dbname) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp li=154

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibSysCommon\scp_rc\ntk.cpp
//-------------------------------------------------
// start of C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp
/**
   @addtogroup tcp_rc
   @{
 */
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=1

/**
   Start trying to connect to server
   @param ip ip to connect to eg '127.0.0.1'
   @param port port to use
 */
remoteCallInitStart( void ip,  void port) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=6

/**
   @internal
   Is the connection to server in progress?
   @return b *long*  \c 1 while the tcp connection is being established
 */
b remoteCallIsIniting() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=39

/**
   Close tcp connection.
 */
rcClientClose() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=61

/**
   @internal
   Client listening loop.
   A client can receive broadcast msgs from server or replies to its requests.
 */
rcClientMain() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=105

/**
   Execute a remote call on server
   @param fnc function to call
   @param args *list* of fnc arguments
   @return fnc may return up to 3 values
 */
fnc rcExec( void fnc,  void args) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=164

/**
   Check connection with server, restore it if lost
   @param tid *long*  thread communication id
   @param ip *L.char*  ip to connect to eg '127.0.0.1'
   @param port *long*  port to use
   @param hostname *L.char* server name.
 */
rcCheckCnx( void tid,  void ip,  void port,  void hostname) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=257

/**
   Helper function to display a connection dialog.
   Establish a connection to server and displays an infinite progress dialog
   while it is being done. Then it launches the main client tcp loop.
   @param ip *long* ip to connect to eg '127.0.0.1'
   @param port *long* port to use
   @param hostname *L.char* server name.

   @note The dialog being modal, any interaction with client GUI is disabled while
   the dialog is displayed.
 */
rcTcpConnect( void ip,  void port,  void hostname) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=372

/**
   Listen on given port.
   Launch a dedicated thread that accepts tcp connections.

   @note How it works:
     -# run remoteCallServerLaunch() when application starts
     -# from now on remoteCallServer run silently in the background...
     -# a remoteCallServerClient thread is launched for each new connection
 */
rcServerLaunch() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=491

/**
   Kill server and all running server clients thread..
   @param tidS server to kill
 */
remoteCallServerKill( void tidS) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=518

/**
   Create communication thread when accepting connection from a client.
 */
remoteCallServer() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=537

/**
   Receive client packet, execute command and returns reply.
   @param newTcp
   @param ip
   @param tidS
 */
remoteCallServerClient( void newTcp,  void ip,  void tidS) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=585

/**
   Close a client communication and unregister it from the server
   @param tidS server id
   @param newTcp channel to close
 */
remoteCallCleanDeadClient( void tidS,  void newTcp) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=642

/**
   Broadcast command to all clients.
   @param fnc function to call on clients
   @param args function arguments
 */
rcBroadcast( void fnc,  void args) {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=661

/**
   Check if client and server are on the same host
   @return 1 if same host.
   @note : on a server, it will return 1
 */
UNK isSameHost() {}
//level=1 fn=C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp li=736

//Kiwi auto close bracket!
/**
 * @}
 */
// END of C:\206-3_11\devLibSysCommon\scp_rc\remoteCallTCP.cpp
//-------------------------------------------------
@} // END namespace